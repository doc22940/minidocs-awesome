
  var css = require('sheetify')
  var minidocs = require('minidocs')
  var app = minidocs({"title":"Dat World","logo":"dat-data-logo.svg","contents":[{"depth":1,"name":"Welcome"},{"depth":2,"name":"Awesome Dat","key":"awesome-dat","link":"/awesome-dat"},{"depth":1,"name":"For the users"},{"depth":2,"name":"maxogden/dat","key":"dat","link":"/dat"},{"depth":2,"name":"juliangruber/dat-desktop","key":"dat-desktop","link":"/dat-desktop"},{"depth":1,"name":"Protocol & Network"},{"depth":2,"name":"datproject/docs","key":"docs","link":"/docs"},{"depth":2,"name":"mafintosh/hypercore","key":"hypercore","link":"/hypercore"},{"depth":2,"name":"mafintosh/hypercore-protocol","key":"hypercore-protocol","link":"/hypercore-protocol"},{"depth":2,"name":"mafintosh/hyperdrive","key":"hyperdrive","link":"/hyperdrive"},{"depth":2,"name":"karissa/hyperdrive-archive-swarm","key":"hyperdrive-archive-swarm","link":"/hyperdrive-archive-swarm"},{"depth":2,"name":"karissa/hyperdrive-ui","key":"hyperdrive-ui","link":"/hyperdrive-ui"},{"depth":1,"name":"Infrastructure"},{"depth":2,"name":"datproject/website","key":"website","link":"/website"},{"depth":1,"name":"Built with dat"},{"depth":2,"name":"CfABrigadePhiladelphia/jawn","key":"jawn","link":"/jawn"}],"markdown":"/Users/joe/node_modules/dat-world/docs","initial":"awesome-dat","basedir":"","dir":"/Users/joe/node_modules/dat-world","routes":{"index":"/","awesome-dat":"/awesome-dat/","dat":"/dat/","dat-desktop":"/dat-desktop/","docs":"/docs/","hypercore":"/hypercore/","hypercore-protocol":"/hypercore-protocol/","hyperdrive":"/hyperdrive/","hyperdrive-archive-swarm":"/hyperdrive-archive-swarm/","hyperdrive-ui":"/hyperdrive-ui/","website":"/website/","jawn":"/jawn/"},"html":{"awesome-dat":"<h1 id=\"awesome-dat-awesome-https-cdn-rawgit-com-sindresorhus-awesome-d7305f38d29fed78fa85652e3a63e154dd8e8829-media-badge-svg-https-github-com-sindresorhus-awesome-\">Awesome dat <a href=\"https://github.com/sindresorhus/awesome\"><img src=\"https://cdn.rawgit.com/sindresorhus/awesome/d7305f38d29fed78fa85652e3a63e154dd8e8829/media/badge.svg\" alt=\"Awesome\"></a></h1>\n<p><a href=\"https://dat-data.com\"><img src=\"http://dat-data.com/static/img/dat-data.png\" align=\"right\" width=\"140\"></a></p>\n<blockquote>\n<p>A curated list of the dat data ecosystem.</p>\n</blockquote>\n<p><em>Inspired by the <a href=\"https://github.com/sindresorhus/awesome\">awesome</a> list thing.</em></p>\n<p><em>Please read the <a href=\"contributing.md\">contribution guidelines</a> before contributing.</em></p>\n<p><a href=\"http://webchat.freenode.net/?channels=dat\"><img src=\"https://img.shields.io/badge/irc%20channel-%23dat%20on%20freenode-blue.svg\" alt=\"#dat IRC channel on freenode\"></a>\n<a href=\"https://gitter.im/datproject/discussions?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge\"><img src=\"https://badges.gitter.im/Join%20Chat.svg\" alt=\"datproject/discussions\"></a></p>\n<p><a href=\"https://github.com/datproject/discussions/issues\">Project discussion</a></p>\n<h2 id=\"for-the-users\">For the users</h2>\n<ul>\n<li>ðŸ“”<a href=\"https://github.com/maxogden/dat\">dat</a> - Main CLI and <a href=\"https://github.com/maxogden/dat/issues\">project planning</a>.</li>\n<li><a href=\"https://github.com/juliangruber/dat-desktop\">dat-desktop</a> - Dat Desktop App.</li>\n</ul>\n<h2 id=\"protocol-network\">Protocol &amp; Network</h2>\n<ul>\n<li><a href=\"https://github.com/datproject/docs/blob/master/docs/hyperdrive_spec.md\">specification</a> - Hyperdrive + Hypercore Specification.</li>\n<li>ðŸ“”<a href=\"https://github.com/mafintosh/hypercore\">hypercore</a> - Protocol and network for distributing and replicating feeds of binary data.</li>\n<li><a href=\"https://github.com/mafintosh/hypercore-protocol\">hypercore-protocol</a> - Stream that implements the hypercore protocol.</li>\n<li>ðŸ“”<a href=\"https://github.com/mafintosh/hyperdrive\">hyperdrive</a> - A file sharing network based on rabin file chunking and append only feeds of data verified by merkle trees.</li>\n<li><a href=\"https://github.com/karissa/hyperdrive-archive-swarm\">hyperdrive-archive-swarm</a> - Join the p2p swarm for a given hyperdrive archive.</li>\n<li><a href=\"https://github.com/karissa/hyperdrive-ui\">hyperdrive-ui</a> - Render a hyperdrive in the browser.</li>\n</ul>\n<h2 id=\"infrastructure\">Infrastructure</h2>\n<ul>\n<li><a href=\"https://github.com/datproject/website\">website</a> - The web site.</li>\n<li><a href=\"https://github.com/datland\">dat.land</a> - Data registry that is being built.</li>\n</ul>\n<h2 id=\"built-with-dat\">Built with dat</h2>\n<ul>\n<li><a href=\"https://github.com/CfABrigadePhiladelphia/jawn\">jawn</a> - Git for Tabular Data.</li>\n</ul>\n<h2 id=\"license\">License</h2>\n<p><a href=\"https://creativecommons.org/publicdomain/zero/1.0/\"><img src=\"http://mirrors.creativecommons.org/presskit/buttons/88x31/svg/cc-zero.svg\" alt=\"CC0\"></a></p>\n<p>To the extent possible under law, <a href=\"https://github.com/clkao\">clkao</a> has waived all copyright and related or neighboring rights to this work.</p>\n","dat":"<h1 id=\"dat\">Dat</h1>\n<p>Dat is a decentralized data tool for distributing data small and large.</p>\n<p><a href=\"http://webchat.freenode.net/?channels=dat\"><img src=\"https://img.shields.io/badge/irc%20channel-%23dat%20on%20freenode-blue.svg\" alt=\"#dat IRC channel on freenode\"></a>\n<a href=\"https://gitter.im/datproject/discussions?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge\"><img src=\"https://badges.gitter.im/Join%20Chat.svg\" alt=\"datproject/discussions\"></a>\n<a href=\"http://docs.dat-data.com\"><img src=\"https://img.shields.io/badge/Dat%20Project-Docs-green.svg\" alt=\"docs\"></a></p>\n<h3 id=\"key-features-\">Key features:</h3>\n<ul>\n<li><strong>Live sync</strong> folders by sharing files as they are added or changed.</li>\n<li><strong>Distribute large files</strong> without copying data to a central server by connecting directly to peers.</li>\n<li><strong>Intelligently sync</strong> by deduplicating data between versions.</li>\n<li><strong>Verify data integrity</strong> using strong cryptographic hashes.</li>\n<li><strong>Work everywhere</strong>, including on the <a href=\"https://github.com/datproject/dat\">command line</a>, in the <a href=\"https://github.com/datproject/dat.land\">browser</a>, and on the <a href=\"https://github.com/juliangruber/dat-desktop\">desktop</a>.</li>\n</ul>\n<h3 id=\"-documentation-http-docs-dat-data-com-video-demo-https-www-youtube-com-watch-v-fxkjsycoqo4-ecosystem-https-github-com-clkao-awesome-dat-\"><a href=\"http://docs.dat-data.com\">Documentation</a> | <a href=\"https://www.youtube.com/watch?v=fxKjSyCoqO4\">Video Demo</a> | <a href=\"https://github.com/clkao/awesome-dat\">Ecosystem</a></h3>\n<hr>\n<h2 id=\"dat-command-line-tool\">Dat Command Line Tool</h2>\n<p>This guide will help you get started with the Dat command line tool. We are also developing <a href=\"https://github.com/datproject/dat.land\">web</a> and <a href=\"https://github.com/juliangruber/dat-desktop\">desktop</a> applications for Dat.</p>\n<h3 id=\"table-of-contents\">Table of Contents</h3>\n<li><a href=\"#getting-started\">Getting Started</a></li>\n<li><a href=\"#using-dat\">Using Dat</a></li>\n<li><a href=\"#troubleshooting\">Troubleshooting</a></li>\n<li><a href=\"#for-developers\">For Developers</a></li>\n\n<h2 id=\"getting-started\">Getting Started</h2>\n<p>The Dat command line tool can be used to share, download, and sync files across many computers via the command line.</p>\n<table>\n<thead>\n<tr>\n<th>Windows</th>\n<th>Mac/Linux</th>\n<th>Version</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://ci.appveyor.com/project/datproject/dat\"><img src=\"https://ci.appveyor.com/api/projects/status/github/datproject/dat?branch=master&amp;svg=true\" alt=\"Build status\"></a></td>\n<td><a href=\"https://travis-ci.org/datproject/dat\"><img src=\"https://api.travis-ci.org/datproject/dat.svg\" alt=\"Travis\"></a></td>\n<td><a href=\"https://npmjs.org/package/dat\"><img src=\"https://img.shields.io/npm/v/dat.svg?style=flat-square\" alt=\"NPM version\"></a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"installation\">Installation</h3>\n<pre><code>npm <span class=\"hljs-keyword\">install</span> -g dat\n</code></pre><p>You should be able to run the <code>dat</code> command now. If not, see the <a href=\"#troubleshooting\">installation troubleshooting</a> for tips.</p>\n<h3 id=\"demo\">Demo</h3>\n<p>We have Dat installed, now let&#39;s use it! In this quick demo we will download our documentation files using Dat.</p>\n<p>You tell Dat what files to download by giving it a Dat link. Dat links are 64 character strings, for example <code>395e3467bb5b2fa083ee8a4a17a706c5574b740b5e1be6efd65754d4ab7328c2</code>.</p>\n<p>Along with the link, you tell Dat where to download the files. All together, you can download files by typing <code>dat &lt;dat-link&gt; &lt;download-directory&gt;</code>.</p>\n<p>We have our Dat documentation folders being shared by Dat (at the key above). For this example, we can download those files to your computer. In your console, run:</p>\n<pre><code>dat <span class=\"hljs-number\">395e3467</span>bb5b2fa083ee8a4a17a706c5574b740b5e1be6efd65754d4ab7328c2 dat_docs\n</code></pre><p>You should see the output below. Once the download is finished, the files will be available on your computer in the <code>dat_docs</code> folder!</p>\n<p><img src=\"https://raw.githubusercontent.com/datproject/docs/master/assets/cli_download.gif\" alt=\"Download gif\"></p>\n<h3 id=\"cli-development-status\">CLI Development Status</h3>\n<p>This is the Dat CLI 1.0 release candidate (RC2). We are actively seeking feedback &amp; developing this release candidate. Follow <a href=\"https://github.com/datproject/projects/issues/5\">this issue</a> for the Dat CLI road map discussion and see <a href=\"https://github.com/datproject/dat/issues/486\">known RC2 issues</a>.</p>\n<p><strong>Please note</strong> that previous versions of Dat (alpha, beta) are incompatible with the 1.0 release candidate.</p>\n<h2 id=\"using-dat\">Using Dat</h2>\n<p>There are two commands in Dat:</p>\n<ol>\n<li>Share data: <code>dat &lt;directory&gt;</code> will share a directory on your computer.</li>\n<li>Download data: <code>dat &lt;dat-link&gt; &lt;download-directory&gt;</code> will download files from the Dat link to a directory on your computer. </li>\n</ol>\n<p>Running <code>dat</code> in the console, with no arguments, will show you the usage guide. You can always use this as a reference for all the commands:</p>\n<pre><code>dat &lt;directory&gt;\n\n  share directory and create a dat-link\n\n  -<span class=\"ruby\">-snapshot            create a snapshot of directory\n</span>  -<span class=\"ruby\">-port, -p            set a specific inbound tcp port\n</span>\ndat &lt;dat-link&gt; &lt;directory&gt;\n\n  download a dat-link into directory\n\n  -<span class=\"ruby\">-exit                exit process after download finishes\n</span>  -<span class=\"ruby\">-port, -p            set a specific inbound tcp port\n</span>\ngeneral options\n\n  -<span class=\"ruby\">-version, -v         get installed dat version\n</span>  -<span class=\"ruby\">-temp                use <span class=\"hljs-keyword\">in</span>-memory database instead of .dat folder\n</span>  -<span class=\"ruby\">-webrtc              connect to webrtc peers via electron-webrtc\n</span>  -<span class=\"ruby\">-doctor              run dat doctor\n</span>  -<span class=\"ruby\">-quiet, -q           output only dat-link, no progress information\n</span>  -<span class=\"ruby\">-debug               show debugging output\n</span>  -<span class=\"ruby\">-ignore-hidden       ignore hidden files (<span class=\"hljs-literal\">true</span> by default)</span>\n</code></pre><h3 id=\"sharing-files\">Sharing Files</h3>\n<p>Share a directory by typing <code>dat &lt;directory&gt;</code>:</p>\n<pre><code>$ dat my_data/\nSharing /Users/joe/my_data/\n\nShare Link: d6e1875598fae25165eff440ffd01513197ad0db9dbb9898f2a141288b9322c6\nThe Share Link <span class=\"hljs-keyword\">is</span> secret <span class=\"hljs-built_in\">and</span> <span class=\"hljs-keyword\">only</span> those you share it with will <span class=\"hljs-keyword\">be</span> able <span class=\"hljs-keyword\">to</span> <span class=\"hljs-built_in\">get</span> the <span class=\"hljs-keyword\">files</span>\n\n[==============&gt;] Added <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">files</span> (<span class=\"hljs-number\">1.44</span> kB/<span class=\"hljs-number\">1.44</span> kB)\n\nConnected <span class=\"hljs-keyword\">to</span> <span class=\"hljs-number\">1</span> peers. Uploading <span class=\"hljs-number\">288.2</span> B/s. Watching <span class=\"hljs-keyword\">for</span> updates...\n</code></pre><p>You are now publishing that data from your computer. It will be publicly accessible as long as your terminal is open and the process is still running. The hash is a <strong>secret hash</strong>, your data is visible to anyone you send the hash to.</p>\n<h4 id=\"updating-shared-files\">Updating Shared Files</h4>\n<p>Dat makes it easy to share a folder and send files as they are added to the folder. By default, when you share using <code>dat my_data/</code> you will be in live sync mode. Anyone connected to you will receive new files.</p>\n<h4 id=\"creating-a-snapshot\">Creating a snapshot</h4>\n<p>A snapshot reads the files and creates a unique link that will always be the same for that set of files (if they remain unchanged). To create a snapshot use the snapshot option: <code>dat my_data/ --snapshot</code>. Snapshots are automatically created for you in live mode as files update.</p>\n<h4 id=\"sharing-options\">Sharing Options</h4>\n<p><code>dat &lt;directory&gt; --snapshot</code></p>\n<p>Share a snapshot of the current files. </p>\n<p><code>dat &lt;directory&gt; --port=1234</code></p>\n<p>Set your inbound TCP port. This is useful for debugging or on restrictive networks. </p>\n<h3 id=\"downloading-files\">Downloading Files</h3>\n<p>Download files from a Dat link by typing: <code>dat &lt;dat-link&gt; &lt;download-directory&gt;</code>:</p>\n<pre><code>$ dat d6e1875598fae25165eff440ffd01513197ad0db9dbb9898f2a141288b9322c6 download_dir\nDownloading in /Users/joe/download_dir\n\nShare Link: d6e1875598fae25165eff440ffd01513197ad0db9dbb9898f2a141288b9322c6\nThe Share Link <span class=\"hljs-keyword\">is</span> secret <span class=\"hljs-built_in\">and</span> <span class=\"hljs-keyword\">only</span> those you share it with will <span class=\"hljs-keyword\">be</span> able <span class=\"hljs-keyword\">to</span> <span class=\"hljs-built_in\">get</span> the <span class=\"hljs-keyword\">files</span>\n\n[==============&gt;] Downloaded <span class=\"hljs-number\">3</span> <span class=\"hljs-keyword\">files</span> (<span class=\"hljs-number\">1.44</span> kB/<span class=\"hljs-number\">1.44</span> kB)\n\nConnected <span class=\"hljs-keyword\">to</span> <span class=\"hljs-number\">1</span> peers. Downloading <span class=\"hljs-number\">1.44</span> kB/s. Watching <span class=\"hljs-keyword\">for</span> updates...\n</code></pre><p>Dat will start downloading the data into the <code>download_dir</code> folder. Once the download is finished (a message will print and the bar will turn green), you can safely exit the process with <code>Ctrl-C</code> (<code>Cmd-C</code> on Mac). </p>\n<p>While downloading, you may be connected to more than 1 peer. Anyone who has the Dat link will be able to download and re-host a copy of the data. So you may be downloading from (and sharing to) other people that are also downloading that data! You only need one block of data to start helping as a host. It&#39;s distributed mad science!</p>\n<h4 id=\"updating-the-downloaded-files\">Updating the Downloaded Files</h4>\n<p>What happens if the files get updated? Dat auto-syncs new files if it is still running. If you exited the process, you can run the same command you ran before (with the same link and directory) and the files will update!</p>\n<h4 id=\"download-options\">Download Options</h4>\n<p><code>dat &lt;dat-link&gt; &lt;directory&gt; --exit</code> </p>\n<p>After files are done downloading, exit the process. If you are connected to a live Dat you will not get new files unless you run the command again.</p>\n<p><code>dat &lt;dat-link&gt; &lt;directory&gt; --port=1234</code></p>\n<p>Set your inbound TCP port. This is useful for debugging or on restrictive networks. </p>\n<h3 id=\"live-sync-snapshots\">Live Sync &amp; Snapshots</h3>\n<p>Dat makes it easy to share a folder and send files as they are changed or added. By default, when you share using Dat you will be in <em>live sync</em> mode. Anyone connected to you will receive file changes as you make them.</p>\n<p>When downloading a Dat, you do not have to worry about live mode. It will automatically start in the right mode based on the link. </p>\n<p>To create a snapshot when sharing files use the snapshot option: <code>dat my_data/ --snapshot</code>. A snapshot reads the files and creates a specific link that will never change (as long as the files don&#39;t change).</p>\n<h3 id=\"dat-metadata-storage\">Dat Metadata Storage</h3>\n<p>When you run a command, Dat creates a hidden folder, <code>.dat</code>, in the directory specified. Similar to git, this folder stores information about your Dat. File metadata and the Dat link are stored to make it easy to continue sharing or downloading the same directory.</p>\n<h4 id=\"temporary-database\">Temporary Database</h4>\n<p>Use the <code>--temp</code> option to keep the metadata in memory instead of the <code>.dat</code> folder.</p>\n<h3 id=\"sharing-or-download-files-with-dat-land-http-dat-land-\">Sharing or Download files with <a href=\"http://dat.land\">dat.land</a></h3>\n<p>You can use the <code>--webrtc</code> option to share files to dat.land. You&#39;ll need to install <code>electron-webrtc</code> in order for this to work.</p>\n<h2 id=\"troubleshooting\">Troubleshooting</h2>\n<p>We&#39;ve provided some troubleshooting tips based on issues users have seen. Please <a href=\"https://github.com/datproject/dat/issues/new\">open an issue</a> or ask us in our <a href=\"https://gitter.im/datproject/discussions\">chat room</a> if you need help troubleshooting and it is not covered here.</p>\n<p>If you have trouble sharing/downloading in a directory with a <code>.dat</code> folder, try deleting it and running the command again.</p>\n<h4 id=\"check-your-dat-version\">Check Your Dat Version</h4>\n<p>Knowing the version is really helpful if you run into any bugs, and will help us troubleshoot your issue.</p>\n<p>Check your Dat version:</p>\n<pre><code><span class=\"hljs-attribute\">dat -v</span>\n</code></pre><p>You should see the Dat semantic version printed, e.g. 11.1.2.</p>\n<h3 id=\"installation-issues\">Installation Issues</h3>\n<h4 id=\"node-npm\">Node &amp; npm</h4>\n<p>To use the Dat command line tool you will need to have <a href=\"https://docs.npmjs.com/getting-started/installing-node\">node and npm installed</a>. Make sure those are installed correctly before installing Dat. You can check the version of each:</p>\n<pre><code><span class=\"hljs-keyword\">node</span> <span class=\"hljs-title\">-v</span>\nnpm -v\n</code></pre><h4 id=\"global-install\">Global Install</h4>\n<p>The <code>-g</code> option installs Dat globally allowing you to run it as a command. Make sure you installed with that option.</p>\n<ul>\n<li>If you receive an <code>EACCES</code> error, read <a href=\"https://docs.npmjs.com/getting-started/fixing-npm-permissions\">this guide</a> on fixing npm permissions.</li>\n<li>If you receive an <code>EACCES</code> error, you may also install dat with sudo: <code>sudo npm install -g dat</code>.</li>\n<li>Have other installation issues? Let us know, you can <a href=\"https://github.com/datproject/dat/issues/new\">open an issue</a> or ask us in our <a href=\"https://gitter.im/datproject/discussions\">chat room</a>.</li>\n</ul>\n<h3 id=\"networking-issues\">Networking Issues</h3>\n<p>Networking capabilities vary widely with each computer, network, and configuration. Whenever you run a Dat there are several steps to share or download files with peers:</p>\n<ol>\n<li>Discovering Peers</li>\n<li>Connecting to Peers</li>\n<li>Sending &amp; Receiving Data</li>\n</ol>\n<p>With successful use, Dat will show <code>Connected to 1 peer</code> after connection. If you never see a peer connected your network may be restricting discovery or connection. Please try using the <code>dat --doctor</code> command (see below) between the two computers not connecting. This will help troubleshoot the networks.</p>\n<ul>\n<li>Dat may <a href=\"https://github.com/datproject/dat/issues/503\">have issues</a> connecting if you are using iptables.</li>\n</ul>\n<h4 id=\"dat-doctor\">Dat Doctor</h4>\n<p>We&#39;ve included a tool to identify network issues with Dat, the Dat doctor. You will need to run the command on both the computers you are trying to share data between. On the first computer, run:</p>\n<pre><code>dat <span class=\"hljs-comment\">--doctor</span>\n</code></pre><p>The doctor will print out a command to run on the other computer, <code>dat --doctor=&lt;64-character-string&gt;</code>. The doctor will run through the key steps in the process of sharing data between computers to help identify the issue.</p>\n<hr>\n<h2 id=\"for-developers\">For Developers</h2>\n<p>Please see <a href=\"https://github.com/datproject/dat/blob/master/CONTRIBUTING.md\">guidelines on contributing</a> before submitting an issue or PR.</p>\n<h3 id=\"installing-from-source\">Installing from source</h3>\n<p>Clone this repository and in a terminal inside of the folder you cloned run this command:</p>\n<pre><code><span class=\"hljs-built_in\">npm</span> link\n</code></pre><p>This should add a <code>dat</code> command line command to your PATH. Now you can run the <code>dat</code> command to try it out.</p>\n<p>The contribution guide also has more tips on our <a href=\"https://github.com/datproject/dat/blob/master/CONTRIBUTING.md#development-workflow\">development workflow</a>.</p>\n<h3 id=\"internal-api\">Internal API</h3>\n<p><strong>Note: we are in the process of moving the js library to a separate module, <a href=\"https://github.com/joehand/dat-js\">joehand/dat-js</a>.</strong></p>\n<h4 id=\"dat-download-cb-\">dat.download(cb)</h4>\n<p>download <code>dat.key</code> to <code>dat.dir</code></p>\n<h4 id=\"dat-share-cb-\">dat.share(cb)</h4>\n<p>share directory specified in <code>opts.dir</code></p>\n<p>Swarm is automatically joined for key when it is available for share &amp; download (<code>dat.joinSwarm()</code>).</p>\n<h4 id=\"events\">Events</h4>\n<h5 id=\"initialization\">Initialization</h5>\n<ul>\n<li><code>dat.on(&#39;ready&#39;)</code>: db created/read &amp; hyperdrive archive created.</li>\n<li><code>dat.on(&#39;error&#39;)</code>: init/database error</li>\n</ul>\n<h5 id=\"swarm\">Swarm</h5>\n<p>Swarm events and stats are available from <code>dat.swarm</code>.</p>\n<ul>\n<li><code>dat.on(&#39;connecting&#39;)</code>: looking for peers</li>\n<li><code>dat.on(&#39;swarm-update&#39;)</code>: peer number changed</li>\n</ul>\n<h5 id=\"share\">Share</h5>\n<ul>\n<li><code>dat.on(&#39;key&#39;)</code>: key is available (this is at archive-finalized for snapshots)</li>\n<li><code>dat.on(&#39;append-ready&#39;)</code>: file count available (<code>dat.appendStats</code>), about to start appending to hyperdrive</li>\n<li><code>dat.on(&#39;file-added&#39;)</code>: file added to archive</li>\n<li><code>dat.on(&#39;upload&#39;, data)</code>: piece of data uploaded</li>\n<li><code>dat.on(&#39;archive-finalized&#39;)</code>: archive finalized, all files appended</li>\n<li><code>dat.on(&#39;archive-updated&#39;)</code>: live archive changed</li>\n</ul>\n<h5 id=\"download\">Download</h5>\n<ul>\n<li><code>dat.on(&#39;key&#39;)</code>: key is available</li>\n<li><code>dat.on(&#39;file-downloaded&#39;, file)</code>: file downloaded</li>\n<li><code>dat.on(&#39;download&#39;, data)</code>: piece of data downloaded</li>\n<li><code>dat.on(&#39;upload&#39;, data)</code>: piece of data uploaded</li>\n<li><code>dat.on(&#39;download-finished&#39;)</code>: archive download finished</li>\n</ul>\n<h4 id=\"other-api\">Other API</h4>\n<ul>\n<li><code>dat.key</code>: key</li>\n<li><code>dat.dir</code>: directory</li>\n<li><code>dat.datPath</code>: path to .dat folder</li>\n<li><code>dat.db</code>: database instance</li>\n<li><code>dat.swarm</code>: hyperdrive-archive-swarm instance</li>\n<li><code>dat.archive</code>: hyperdrive archive</li>\n<li><code>dat.snapshot</code> (boolean): sharing snapshot archive</li>\n</ul>\n<h4 id=\"internal-stats\">Internal Stats</h4>\n<pre><code class=\"lang-javascript\">\ndat.stats = {\n    filesTotal: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// Latest archive size</span>\n    bytesTotal: <span class=\"hljs-number\">0</span>,\n    bytesUp: <span class=\"hljs-number\">0</span>,\n    bytesDown: <span class=\"hljs-number\">0</span>,\n    rateUp: speedometer(),\n    rateDown: speedometer()\n}\n\n<span class=\"hljs-comment\">// Calculated on share before append starts. Used for append progress.</span>\n<span class=\"hljs-comment\">// Not updated for live.</span>\ndat.appendStats = {\n    files: <span class=\"hljs-number\">0</span>,\n    bytes: <span class=\"hljs-number\">0</span>,\n    dirs: <span class=\"hljs-number\">0</span>\n}\n</code></pre>\n<h2 id=\"license\">License</h2>\n<p>BSD-3-Clause</p>\n","dat-desktop":"<h1 id=\"dat-desktop\">dat-desktop</h1>\n<p>WIP desktop app for <a href=\"https://github.com/maxogden/dat\">dat</a>.</p>\n<p><img src=\"screenshot.png\" alt=\"\"></p>\n<p><a href=\"https://travis-ci.org/juliangruber/dat-desktop\"><img src=\"https://travis-ci.org/juliangruber/dat-desktop.svg?branch=master\" alt=\"Build Status\"></a></p>\n<h2 id=\"running\">Running</h2>\n<pre><code class=\"lang-bash\">$ npm install\n$ npm run rebuild\n$ npm start\n</code></pre>\n<h2 id=\"watch-and-compile-scss\">Watch and compile SCSS</h2>\n<pre><code class=\"lang-bash\">$ npm run watch-css\n</code></pre>\n<p>Then drop files onto the app window and watch the console.</p>\n<h2 id=\"cli\">CLI</h2>\n<p>-- <code>--data=DIR</code> overwrite the data path</p>\n<h2 id=\"styles\">Styles</h2>\n<p>For now, check out</p>\n<ul>\n<li><code>lib/render.js</code> for html</li>\n<li><code>/scss/main.scss</code> for scss</li>\n</ul>\n<p>Styles are imported from <a href=\"https://github.com/datproject/design\">https://github.com/datproject/design</a>. All variables, mixins, and component styles are available in main.</p>\n<p>There&#39;s also the html being generated by <a href=\"https://github.com/karissa/hyperdrive-ui\">hyperdrive-ui</a>.</p>\n<h2 id=\"license\">License</h2>\n<p>  MIT</p>\n","docs":"<h2 id=\"dat-project-documentation\">Dat Project Documentation</h2>\n<p>Repository for the documentation of the Dat Project ecosystem. View the docs at <a href=\"http://docs.dat-data.com\">docs.dat-data.com</a>.</p>\n<p><a href=\"http://webchat.freenode.net/?channels=dat\"><img src=\"https://img.shields.io/badge/irc%20channel-%23dat%20on%20freenode-blue.svg\" alt=\"#dat IRC channel on freenode\"></a>\n<a href=\"https://gitter.im/datproject/discussions?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge\"><img src=\"https://badges.gitter.im/Join%20Chat.svg\" alt=\"datproject/discussions\"></a>\n<a href=\"http://docs.dat-data.com\"><img src=\"https://img.shields.io/badge/Dat%20Project-Docs-green.svg\" alt=\"docs\"></a></p>\n<h2 id=\"writing-editing-docs\">Writing &amp; Editing Docs</h2>\n<p><a href=\"docs/readme.md\">See docs folder</a> for information on editing and adding docs. Once you finish editing the docs, follow the update &amp; deploy docs instructions.</p>\n<h2 id=\"installation-usage\">Installation &amp; Usage</h2>\n<p>This documentation uses <a href=\"https://www.npmjs.com/package/minidocs\">minidocs</a>.</p>\n<h3 id=\"viewing-docs-locally\">Viewing Docs Locally</h3>\n<ol>\n<li>Clone Repository</li>\n<li><code>npm install</code></li>\n<li><code>npm run build:local</code> to build the docs for local viewing</li>\n<li><code>npm run start</code> to view the docs in browser</li>\n</ol>\n<h3 id=\"updating-deploying-docs\">Updating &amp; Deploying Docs</h3>\n<ol>\n<li>Clone Repository</li>\n<li><code>npm install</code></li>\n<li>Make documentation edits</li>\n<li><code>npm run deploy</code> to build docs &amp; deploy to GitHub pages.`</li>\n</ol>\n<h3 id=\"updating-external-module-docs\">Updating External Module Docs</h3>\n<p>We use <a href=\"https://github.com/hughsk/ecosystem-docs\">ecosystem-docs</a> to get documentation from other modules.</p>\n<ol>\n<li><code>npm run update</code> will update the list of repositories and download the latest docs.</li>\n<li>Deploy!</li>\n</ol>\n<h2 id=\"npm-commands\">NPM Commands</h2>\n<p>All the npm commands</p>\n<ul>\n<li><code>npm run deploy</code>: build and deploy to github</li>\n<li><code>npm run build:deploy</code>: build full html pages &amp; css for deployment</li>\n<li><code>npm run build:local</code>: build app &amp; css for local viewing</li>\n<li><code>npm start</code>: start budo server to view locally</li>\n<li><code>npm run build:css</code>: build css, runs with both build commands</li>\n<li><code>npm run watch:css</code>: watch css live and build:local with changes</li>\n<li><code>npm update</code>: run both update commands</li>\n<li><code>npm run update:list</code> updates the repository list only</li>\n<li><code>npm run update:build</code> downloads the latest readme to the docs folder.</li>\n<li><code>npm run paper</code>: create the paper with pandoc</li>\n</ul>\n<h2 id=\"license\">License</h2>\n<p>ISC</p>\n","hypercore":"<h1 id=\"hypercore\">hypercore</h1>\n<p>Hypercore is a protocol and p2p network for distributing and replicating feeds of binary data. It is the low level component that <a href=\"https://github.com/mafintosh/hyperdrive\">Hyperdrive</a> is built on top of.</p>\n<pre><code>npm <span class=\"hljs-keyword\">install</span> hypercore\n</code></pre><p><a href=\"http://travis-ci.org/mafintosh/hypercore\"><img src=\"http://img.shields.io/travis/mafintosh/hypercore.svg?style=flat\" alt=\"build status\"></a></p>\n<p>It runs both in the node and in the browser using <a href=\"https://github.com/substack/node-browserify\">browserify</a>.</p>\n<h2 id=\"usage\">Usage</h2>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> hypercore = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'hypercore'</span>)\n<span class=\"hljs-keyword\">var</span> net = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'net'</span>)\n\n<span class=\"hljs-keyword\">var</span> core = hypercore(db) <span class=\"hljs-comment\">// db is a leveldb instance</span>\n<span class=\"hljs-keyword\">var</span> feed = core.createFeed()\n\nfeed.append([<span class=\"hljs-string\">'hello'</span>, <span class=\"hljs-string\">'world'</span>], <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'appended two blocks'</span>)\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'key is'</span>, feed.key.toString(<span class=\"hljs-string\">'hex'</span>))\n})\n\nfeed.on(<span class=\"hljs-string\">'upload'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">block, data</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'uploaded block'</span>, block, data)\n})\n\n<span class=\"hljs-keyword\">var</span> server = net.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">socket</span>) </span>{\n  socket.pipe(feed.replicate()).pipe(socket)\n})\n\nserver.listen(<span class=\"hljs-number\">10000</span>)\n</code></pre>\n<p>In another process</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> core = hypercore(anotherDb)\n<span class=\"hljs-keyword\">var</span> feed = core.createFeed(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">key-printed-out-above</span>&gt;</span>)\nvar socket = net.connect(10000)\n\nsocket.pipe(feed.replicate()).pipe(socket)\n\nfeed.on('download', function (block, data) {\n  console.log('downloaded block', block, data)\n})</span>\n</code></pre>\n<h2 id=\"api\">API</h2>\n<h4 id=\"-var-core-hypercore-db-\"><code>var core = hypercore(db)</code></h4>\n<p>Create a new hypercore instance. <code>db</code> should be a leveldb instance.</p>\n<h4 id=\"-var-feed-core-createfeed-key-options-\"><code>var feed = core.createFeed([key], [options])</code></h4>\n<p>Create a new feed. A feed stores a list of append-only data (buffers). A feed has a <code>.key</code> property that you can pass in to <code>createFeed</code> if you want to retrieve an old feed. Per default all feeds are appendable (live).</p>\n<p>Options include:</p>\n<pre><code class=\"lang-js\">{\n  live: <span class=\"hljs-literal\">true</span>,\n  storage: externalStorage,\n  sparse: <span class=\"hljs-literal\">false</span>\n}\n</code></pre>\n<p>Set <code>sparse</code> to <code>true</code> if you only want to download the pieces of the feed you are requesting / prioritizing. Otherwise the entire feed will be downloaded if nothing else is prioritized.</p>\n<p>If you want to create a static feed, one you cannot reappend data to, pass the <code>{live: false}</code> option.\nThe storage option allows you to store data outside of leveldb. This is very useful if you use hypercore to distribute files.</p>\n<p>See the <a href=\"#storage-api\">Storage API</a> section for more info</p>\n<h4 id=\"-var-stream-core-replicate-opts-\"><code>var stream = core.replicate(opts)</code></h4>\n<p>Create a generic replication stream. Use the <code>feed.replicate(stream)</code> API described below to replicate specific feeds of data.\nOptions include:</p>\n<pre><code class=\"lang-js\">{\n  upload: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">// upload data to other peer</span>\n  download: <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// download data from other peer</span>\n}\n</code></pre>\n<h4 id=\"-var-stream-core-list-options-callback-\"><code>var stream = core.list([options], [callback])</code></h4>\n<p>List all feed keys in the database. Optionally you can pass a callback to buffer them into an array. Options include:</p>\n<pre><code class=\"lang-js\">{\n  values: <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// set this to get feed attributes, not just feed keys</span>\n}\n</code></pre>\n<h2 id=\"-feed-api-\"><code>Feed API</code></h2>\n<p>As mentioned above a feed stores a list of data for you that you can replicate to other peers. It has the following API</p>\n<h4 id=\"-feed-key-\"><code>feed.key</code></h4>\n<p>The key of this feed. A 32 byte buffer. Other peers need this key to start replicating the feed.</p>\n<h4 id=\"-feed-discoverykey-\"><code>feed.discoveryKey</code></h4>\n<p>A 32 byte buffer containing a discovery key of the feed. The discovery key is sha-256 hmac of the string <code>hypercore</code> using the feed key as the password.\nYou can use the discovery key to find other peers sharing this feed without disclosing your feed key to a third party.</p>\n<h4 id=\"-feed-blocks-\"><code>feed.blocks</code></h4>\n<p>The total number of known data blocks in the feed.</p>\n<h4 id=\"-feed-bytes-\"><code>feed.bytes</code></h4>\n<p>The total byte size of known data blocks in the feed.</p>\n<h4 id=\"-feed-open-cb-\"><code>feed.open(cb)</code></h4>\n<p>Call this method to ensure that a feed is opened. You do not need to call this but the <code>.blocks</code> property will not be populated until the feed has been opened.</p>\n<h4 id=\"-feed-append-data-callback-\"><code>feed.append(data, callback)</code></h4>\n<p>Append a block of data to the feed. If you want to append more than one block you can pass in an array.</p>\n<h4 id=\"-feed-get-index-callback-\"><code>feed.get(index, callback)</code></h4>\n<p>Retrieve a block of data from the feed.</p>\n<h4 id=\"-feed-prioritize-range-callback-\"><code>feed.prioritize(range, [callback])</code></h4>\n<p>Prioritize a range of blocks to download. Will call the callback when done.\nRange should look like this</p>\n<pre><code class=\"lang-js\">{\n  start: startBlock,\n  end: optionalEndBlock,\n  priority: <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// a priority level spanning [0-5]</span>\n  linear: <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// download the range linearly</span>\n}\n</code></pre>\n<h4 id=\"-feed-unprioritize-range-\"><code>feed.unprioritize(range)</code></h4>\n<p>Unprioritize a range.</p>\n<h4 id=\"-feed-seek-byteoffset-callback-\"><code>feed.seek(byteOffset, callback)</code></h4>\n<p>Find the block of data containing the byte offset. Calls the callback with <code>(err, index, offset)</code> where <code>index</code> is the block index and <code>offset</code> is the the relative byte offset in the block returned by <code>.get(index)</code>.</p>\n<h4 id=\"-feed-finalize-callback-\"><code>feed.finalize(callback)</code></h4>\n<p>If you are not using a live feed you need to call this method to finalize the feed once you are ready to share it.\nFinalizing will set the <code>.key</code> property and allow other peers to get your data.</p>\n<h4 id=\"-var-stream-feed-createwritestream-options-\"><code>var stream = feed.createWriteStream([options])</code></h4>\n<p>Create a writable stream that appends to the feed. If the feed is a static feed, it will be finalized when you end the stream.</p>\n<h4 id=\"-var-stream-feed-createreadstream-options-\"><code>var stream = feed.createReadStream([options])</code></h4>\n<p>Create a readable stream that reads from the feed. Options include:</p>\n<pre><code class=\"lang-js\">{\n  start: startIndex, <span class=\"hljs-comment\">// read from this index</span>\n  end: endIndex, <span class=\"hljs-comment\">// read until this index</span>\n  live: <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// set this to keep the read stream open</span>\n}\n</code></pre>\n<h4 id=\"-var-stream-feed-replicate-options-\"><code>var stream = feed.replicate([options])</code></h4>\n<p>Get a replication stream for this feed. Pipe this to another peer to start replicating this feed with another peer.\nIf you create multiple replication streams to multiple peers you&#39;ll upload/download data to all of them (meaning the load will spread out).</p>\n<p>Per default the replication stream encrypts all messages sent using the feed key and an incrementing nonce. This helps ensures that the remote peer also the feed key and makes it harder for a man-in-the-middle to sniff the data you are sending.</p>\n<p>Set <code>{private: false}</code> to disable this.</p>\n<p>Hypercore uses a simple multiplexed protocol that allows one replication stream to be used for multiple feeds at once.\nIf you want to join another replication stream simply pass it as the stream option</p>\n<pre><code class=\"lang-js\">feed.replicate({stream: anotherReplicationStream})\n</code></pre>\n<p>As a shorthand you can also do <code>feed.replicate(stream)</code>.</p>\n<h4 id=\"-stream-on-open-discoverykey-\"><code>stream.on(&#39;open&#39;, discoveryKey)</code></h4>\n<p>Emitted when a remote feed joins the replication stream and you haven&#39;t. You can use this as a signal to join the stream yourself if you want to.</p>\n<h4 id=\"-feed-on-download-block-data-\"><code>feed.on(&#39;download&#39;, block, data)</code></h4>\n<p>Emitted when a data block has been downloaded</p>\n<h4 id=\"-feed-on-download-finished-\"><code>feed.on(&#39;download-finished&#39;)</code></h4>\n<p>Emitted when all available data has been downloaded.\nWill re-fire when a live feed is updated and you download all the new blocks.</p>\n<h4 id=\"-feed-on-upload-block-data-\"><code>feed.on(&#39;upload&#39;, block, data)</code></h4>\n<p>Emitted when a data block has been uploaded</p>\n<h2 id=\"storage-api\">Storage API</h2>\n<p>If you want to use external storage to store the hypercore data (metadata will still be stored in the leveldb) you need to implement the following api and provide that as the <code>storage</code> option when creating a feed.</p>\n<p>Some node modules that implement this interface are</p>\n<ul>\n<li><a href=\"https://github.com/mafintosh/random-access-file\">random-access-file</a> Writes data to a file.</li>\n<li><a href=\"https://github.com/mafintosh/random-access-memory\">random-access-memory</a> Writes data to memory.</li>\n</ul>\n<h4 id=\"-storage-open-cb-\"><code>storage.open(cb)</code></h4>\n<p>This API is <em>optional</em>. If you provide this hypercore will call <code>.open</code> and wait for the callback to be called before calling any other methods.</p>\n<h4 id=\"-storage-read-offset-length-cb-\"><code>storage.read(offset, length, cb)</code></h4>\n<p>This API is <em>required</em>. Hypercore calls this when it wants to read data. You should return a buffer with length <code>length</code> that way read at the corresponding offset. If you cannot read this buffer call the callback with an error.</p>\n<h4 id=\"-storage-write-offset-buffer-cb-\"><code>storage.write(offset, buffer, cb)</code></h4>\n<p>This API is <em>required</em>. Hypercore calls this when it wants to write data. You should write the buffer at the corresponding offset and call the callback afterwards. If there was an error writing you should call the callback with that error.</p>\n<h4 id=\"-storage-close-cb-\"><code>storage.close(cb)</code></h4>\n<p>This API is <em>optional</em>. Hypercore will call this method when the feed is closing.</p>\n<h2 id=\"license\">License</h2>\n<p>MIT</p>\n","hypercore-protocol":"<h1 id=\"hypercore-protocol\">hypercore-protocol</h1>\n<p>Stream that implements the <a href=\"https://github.com/mafintosh/hypercore\">hypercore</a> protocol</p>\n<pre><code>npm <span class=\"hljs-keyword\">install</span> hypercore-protocol\n</code></pre><p><a href=\"https://travis-ci.org/mafintosh/hypercore-protocol\"><img src=\"https://travis-ci.org/mafintosh/hypercore-protocol.svg?branch=master\" alt=\"build status\"></a></p>\n<h2 id=\"usage\">Usage</h2>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> protocol = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'hypercore-protocol'</span>)\n\n<span class=\"hljs-keyword\">var</span> p = protocol()\n\n<span class=\"hljs-comment\">// open a channel specified by a 32 byte key</span>\n<span class=\"hljs-keyword\">var</span> channel = p.open(Buffer(<span class=\"hljs-string\">'deadbeefdeadbeefdeadbeefdeadbeef'</span>))\n\nchannel.request({block: <span class=\"hljs-number\">42</span>})\nchannel.on(<span class=\"hljs-string\">'data'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">message</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(message) <span class=\"hljs-comment\">// contains message.block and message.value</span>\n})\n\nstream.pipe(anotherStream).pipe(stream)\n</code></pre>\n<h2 id=\"api\">API</h2>\n<h4 id=\"-var-k-protocol-parsediscoverykey-buf-\"><code>var k = protocol.parseDiscoveryKey(buf)</code></h4>\n<p>Parse the discovery key encoded in <code>buf</code> which is the first varint message taken from a hypercore feed stream.</p>\n<h4 id=\"-var-p-protocol-options-onopen-\"><code>var p = protocol([options], [onopen])</code></h4>\n<p>Create a new protocol instance. The returned object is a duplex stream\nthat you should pipe to another protocol instance over a stream based transport</p>\n<p>If the remote peer joins a channel you haven&#39;t opened, hypercore will call an optional <code>onopen</code>\nmethod if you specify it with the discovery key for that channel.</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> p = protocol(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">discoveryKey</span>) </span>{\n  <span class=\"hljs-comment\">// remote peer joined discoveryKey but you haven't</span>\n  <span class=\"hljs-comment\">// you can open the channel now if you want to join the channel</span>\n\n  <span class=\"hljs-comment\">// open with corresponding key to join</span>\n  <span class=\"hljs-keyword\">var</span> channel = p.open(Buffer(<span class=\"hljs-string\">'deadbeefdeadbeefdeadbeefdeadbeef'</span>))\n})\n</code></pre>\n<p>See below for more information about channels, keys, and discovery keys.\nOther options include:</p>\n<pre><code class=\"lang-js\">{\n  id: optionalPeerId, <span class=\"hljs-comment\">// you can use this to detect if you connect to yourself</span>\n  encrypt: <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">// set to false to disable encryption for debugging purposes</span>\n}\n</code></pre>\n<p>If you don&#39;t specify a peer id a random 32 byte will be used.\nYou can access the peer id using <code>p.id</code> and the remote peer id using <code>p.remoteId</code>.</p>\n<h4 id=\"-var-channel-p-open-key-options-\"><code>var channel = p.open(key, [options])</code></h4>\n<p>Open a stream channel. A channel uses the <a href=\"https://github.com/mafintosh/sodium-prebuilt\">sodium</a> module to encrypt all messages using the key you specify. The discovery key for the channel is send unencrypted together with a random 24 byte nonce. If you do not specify a discovery key in the options map, an HMAC of the string <code>hypercore</code> using the key as the password will be used.</p>\n<h4 id=\"-p-on-handshake-\"><code>p.on(&#39;handshake&#39;)</code></h4>\n<p>Emitted when a protocol handshake has been received. Afterwards you can check <code>.remoteId</code> to get the remote peer id.</p>\n<h4 id=\"-p-settimeout-ms-ontimeout-\"><code>p.setTimeout(ms, [ontimeout])</code></h4>\n<p>Will call the timeout function if the remote peer hasn&#39;t send any messages within <code>ms</code>. Will also send a heartbeat message to the other peer if you&#39;ve been inactive for <code>ms / 2</code></p>\n<h2 id=\"channel-api\">Channel API</h2>\n<h4 id=\"-channel-end-\"><code>channel.end()</code></h4>\n<p>Ends a channel</p>\n<h4 id=\"-channel-on-end-\"><code>channel.on(&#39;end&#39;)</code></h4>\n<p>Emitted when a channel is ended, either by you or the remote peer.\nNo other events will be emitted after this.</p>\n<h4 id=\"-channel-request-message-\"><code>channel.request(message)</code></h4>\n<p>Send a request message. See the protobuf schema or more information</p>\n<h4 id=\"-channel-on-request-message-\"><code>channel.on(&#39;request&#39;, message)</code></h4>\n<p>Emitted when a request message is received</p>\n<h4 id=\"-channel-data-message-\"><code>channel.data(message)</code></h4>\n<p>Send a data message. See the protobuf schema or more information</p>\n<h4 id=\"-channel-on-data-message-\"><code>channel.on(&#39;data&#39;, message)</code></h4>\n<p>Emitted when a data message is received</p>\n<h4 id=\"-channel-cancel-message-\"><code>channel.cancel(message)</code></h4>\n<p>Send a cancel message. See the protobuf schema or more information</p>\n<h4 id=\"-channel-on-cancel-message-\"><code>channel.on(&#39;cancel&#39;, message)</code></h4>\n<p>Emitted when a cancel message is received</p>\n<h4 id=\"-channel-have-message-\"><code>channel.have(message)</code></h4>\n<p>Send a have message. See the protobuf schema or more information</p>\n<h4 id=\"-channel-on-have-message-\"><code>channel.on(&#39;have&#39;, message)</code></h4>\n<p>Emitted when a have message is received</p>\n<h4 id=\"-channel-want-message-\"><code>channel.want(message)</code></h4>\n<p>Send a want message. See the protobuf schema or more information</p>\n<h4 id=\"-channel-on-want-message-\"><code>channel.on(&#39;want&#39;, message)</code></h4>\n<p>Emitted when a want message is received</p>\n<h4 id=\"-channel-resume-\"><code>channel.resume()</code></h4>\n<p>Send a resume signal</p>\n<h4 id=\"-channel-on-resume-\"><code>channel.on(&#39;resume&#39;)</code></h4>\n<p>Emitted when a resume signal is received</p>\n<h4 id=\"-channel-pause-\"><code>channel.pause()</code></h4>\n<p>Send a pause signal</p>\n<h4 id=\"-channel-on-pause-\"><code>channel.on(&#39;pause&#39;)</code></h4>\n<p>Emitted when a pause signal is received</p>\n<p>You can always check the paused state by accessing <code>.remotePaused</code> and <code>.amPaused</code>\nto see wheather or not the remote is pausing us or we are pausing the remote.</p>\n<h2 id=\"extension-api\">Extension API</h2>\n<h4 id=\"-protocol-protocol-use-extensionname-\"><code>protocol = protocol.use(extensionName)</code></h4>\n<p>Use an extension specified by the string name you pass in. Returns a new prototype</p>\n<p>Will create a new method on all your channel objects that has the same name as the extension and emit an event with the same name when an extension message is received</p>\n<pre><code class=\"lang-js\">protocol = protocol.use(<span class=\"hljs-string\">'ping'</span>)\n\n<span class=\"hljs-keyword\">var</span> p = protocol()\n<span class=\"hljs-keyword\">var</span> channel = p.open(someKey)\n\nchannel.on(<span class=\"hljs-string\">'handshake'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  channel.on(<span class=\"hljs-string\">'ping'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">message</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'received ping message'</span>, message)\n  })\n\n  channel.ping(Buffer(<span class=\"hljs-string\">'this is a ping message!'</span>))\n})\n</code></pre>\n<p>Per default all messages are buffers. If you want to encode/decode your messages you can specify an <a href=\"https://github.com/mafintosh/abstract-encoding\">abstract-encoding</a> compliant encoder as well</p>\n<pre><code class=\"lang-js\">protocol = protocol.use({\n  ping: someEncoder\n})\n</code></pre>\n<h4 id=\"-var-bool-p-remotesupports-extensionname-\"><code>var bool = p.remoteSupports(extensionName)</code></h4>\n<p>After the protocol instance emits <code>handshake</code> you can call this method to check\nif the remote peer also supports one of your extensions.</p>\n<h2 id=\"license\">License</h2>\n<p>MIT</p>\n","hyperdrive":"<h1 id=\"hyperdrive\">hyperdrive</h1>\n<p>A file sharing network based on <a href=\"https://github.com/maxogden/rabin\">rabin</a> file chunking and <a href=\"https://github.com/mafintosh/hypercore\">append only feeds of data verified by merkle trees</a>.</p>\n<pre><code>npm <span class=\"hljs-keyword\">install</span> hyperdrive\n</code></pre><p><a href=\"http://travis-ci.org/mafintosh/hyperdrive\"><img src=\"http://img.shields.io/travis/mafintosh/hyperdrive.svg?style=flat\" alt=\"build status\"></a></p>\n<p>If you are interested in learning how hyperdrive works on a technical level a specification is available in the <a href=\"https://github.com/datproject/docs/blob/master/docs/hyperdrive_spec.md\">Dat docs repo</a></p>\n<h2 id=\"usage\">Usage</h2>\n<p>First create a new feed and share it</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> hyperdrive = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'hyperdrive'</span>)\n<span class=\"hljs-keyword\">var</span> level = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'level'</span>)\n<span class=\"hljs-keyword\">var</span> swarm = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'discovery-swarm'</span>)()\n\n<span class=\"hljs-keyword\">var</span> db = level(<span class=\"hljs-string\">'./hyperdrive.db'</span>)\n<span class=\"hljs-keyword\">var</span> drive = hyperdrive(db)\n\n<span class=\"hljs-keyword\">var</span> archive = drive.createArchive()\n<span class=\"hljs-keyword\">var</span> ws = archive.createFileWriteStream(<span class=\"hljs-string\">'hello.txt'</span>) <span class=\"hljs-comment\">// add hello.txt</span>\n\nws.write(<span class=\"hljs-string\">'hello'</span>)\nws.write(<span class=\"hljs-string\">'world'</span>)\nws.end()\n\n<span class=\"hljs-keyword\">var</span> link = archive.key.toString(<span class=\"hljs-string\">'hex'</span>)\n<span class=\"hljs-built_in\">console</span>.log(link, <span class=\"hljs-string\">'&lt;-- this is your hyperdrive link'</span>)\n\n<span class=\"hljs-comment\">// the archive is now ready for sharing.</span>\n<span class=\"hljs-comment\">// we can use swarm to replicate it to other peers</span>\nswarm.listen()\nswarm.join(<span class=\"hljs-keyword\">new</span> Buffer(link, <span class=\"hljs-string\">'hex'</span>))\nswarm.on(<span class=\"hljs-string\">'connection'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">connection</span>) </span>{\n  connection.pipe(archive.replicate()).pipe(connection)\n})\n</code></pre>\n<p>Then we can access the content from another process with the following code</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> swarm = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'discovery-swarm'</span>)()\n<span class=\"hljs-keyword\">var</span> hyperdrive = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'hyperdrive'</span>)\n<span class=\"hljs-keyword\">var</span> level = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'level'</span>)\n\n<span class=\"hljs-keyword\">var</span> db = level(<span class=\"hljs-string\">'./another-hyperdrive.db'</span>)\n<span class=\"hljs-keyword\">var</span> drive = hyperdrive(db)\n\n<span class=\"hljs-keyword\">var</span> link = <span class=\"hljs-keyword\">new</span> Buffer(<span class=\"hljs-string\">'your-hyperdrive-link-from-the-above-example'</span>, <span class=\"hljs-string\">'hex'</span>)\n<span class=\"hljs-keyword\">var</span> archive = drive.createArchive(link)\n\nswarm.listen()\nswarm.join(link)\nswarm.on(<span class=\"hljs-string\">'connection'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">connection</span>) </span>{\n  connection.pipe(archive.replicate()).pipe(connection)\n  archive.get(<span class=\"hljs-number\">0</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, entry</span>) </span>{ <span class=\"hljs-comment\">// get the first file entry</span>\n    <span class=\"hljs-built_in\">console</span>.log(entry) <span class=\"hljs-comment\">// prints {name: 'hello.txt', ...}</span>\n    <span class=\"hljs-keyword\">var</span> stream = archive.createFileReadStream(entry)\n    stream.on(<span class=\"hljs-string\">'data'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">data</span>) </span>{\n      <span class=\"hljs-built_in\">console</span>.log(data) <span class=\"hljs-comment\">// &lt;-- file data</span>\n    })\n    stream.on(<span class=\"hljs-string\">'end'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'no more data'</span>)\n    })\n  })\n})\n</code></pre>\n<p>If you want to write/read files to the file system provide a storage driver as the file option</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> raf = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'random-access-file'</span>) <span class=\"hljs-comment\">// a storage driver that writes to the file system</span>\n<span class=\"hljs-keyword\">var</span> archive = drive.createArchive({\n  file: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> raf(<span class=\"hljs-string\">'my-download-folder/'</span> + name)\n  }\n})\n</code></pre>\n<h2 id=\"api\">API</h2>\n<h4 id=\"-var-drive-hyperdrive-db-\"><code>var drive = hyperdrive(db)</code></h4>\n<p>Create a new hyperdrive instance. db should be a <a href=\"https://github.com/level/levelup\">levelup</a> instance.</p>\n<h4 id=\"-var-archive-drive-createarchive-key-options-\"><code>var archive = drive.createArchive([key], [options])</code></h4>\n<p>Creates an archive instance. If you want to download/upload an existing archive provide the archive key\nas the first argument. Options include</p>\n<pre><code class=\"lang-js\">{\n  live: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-comment\">// set this to share the archive without finalizing it</span>\n  sparse: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-comment\">// set this to only download the pieces of the feed you are requesting / prioritizing</span>\n  file: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name</span>) </span>{\n    <span class=\"hljs-comment\">// set this to determine how file data is stored.</span>\n    <span class=\"hljs-comment\">// the storage instance should implement the hypercore storage api</span>\n    <span class=\"hljs-comment\">// https://github.com/mafintosh/hypercore#storage-api</span>\n    <span class=\"hljs-keyword\">return</span> someStorageInstance\n  }\n}\n</code></pre>\n<p>If you do not provide the file option all file data is stored in the leveldb.</p>\n<h4 id=\"-archive-key-\"><code>archive.key</code></h4>\n<p>A buffer that verifies the archive content. In live mode this is a 32 byte public key.\nOtherwise it is a 32 byte hash.</p>\n<h4 id=\"-archive-live-\"><code>archive.live</code></h4>\n<p>Boolean whether archive is live. <code>true</code> by default. Note that its only populated after archive.open(cb) has been fired.</p>\n<h4 id=\"-archive-append-entry-callback-\"><code>archive.append(entry, callback)</code></h4>\n<p>Append an entry to the archive. Only possible if this is an live archive you originally created\nor an unfinalized archive.</p>\n<p>If you set the file option in the archive constructor you can use this method to append an already\nexisting file to the archive.</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> archive = drive.createArchive({\n  file: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'returning storage for'</span>, name)\n    <span class=\"hljs-keyword\">return</span> raf(name)\n  }\n})\n\narchive.append(<span class=\"hljs-string\">'hello.txt'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'hello.txt was read and appended'</span>)\n})\n</code></pre>\n<h4 id=\"-archive-finalize-callback-\"><code>archive.finalize([callback])</code></h4>\n<p>Finalize the archive. You need to do this before sharing it if the archive is not live (it is live per default).</p>\n<h4 id=\"-archive-get-index-callback-\"><code>archive.get(index, callback)</code></h4>\n<p>Reads an entry from the archive.</p>\n<h4 id=\"-archive-download-index-callback-\"><code>archive.download(index, callback)</code></h4>\n<p>Fully downloads a file / entry from the archive and calls the callback afterwards.</p>\n<h4 id=\"-archive-close-callback-\"><code>archive.close([callback])</code></h4>\n<p>Closes and releases all resources used by the archive. Call this when you are done using it.</p>\n<h4 id=\"-archive-on-download-data-\"><code>archive.on(&#39;download&#39;, data)</code></h4>\n<p>Emitted every time a piece of data is downloaded</p>\n<h4 id=\"-archive-on-upload-data-\"><code>archive.on(&#39;upload&#39;, data)</code></h4>\n<p>Emitted every time a piece of data is uploaded</p>\n<h4 id=\"-var-rs-archive-list-opts-cb-\"><code>var rs = archive.list(opts={}, cb)</code></h4>\n<p>Returns a readable stream of all entries in the archive.</p>\n<ul>\n<li><code>opts.offset</code> - start streaming from this offset (default: 0)</li>\n<li><code>opts.live</code> - keep the stream open as new updates arrive (default: false)</li>\n</ul>\n<p>You can collect the results of the stream with <code>cb(err, entries)</code>.</p>\n<h4 id=\"-var-rs-archive-createfilereadstream-entry-options-\"><code>var rs = archive.createFileReadStream(entry, [options])</code></h4>\n<p>Returns a readable stream of the file content of an file in the archive.</p>\n<p>Options include:</p>\n<pre><code class=\"lang-js\">{\n  start: startOffset, <span class=\"hljs-comment\">// defaults to 0</span>\n  end: endOffset <span class=\"hljs-comment\">// defaults to file.length</span>\n}\n</code></pre>\n<h4 id=\"-var-ws-archive-createfilewritestream-entry-\"><code>var ws = archive.createFileWriteStream(entry)</code></h4>\n<p>Returns a writable stream that writes a new file to the archive. Only possible if the archive is live and you own it\nor if the archive is not finalized.</p>\n<h4 id=\"-var-cursor-archive-createbytecursor-entry-options-\"><code>var cursor = archive.createByteCursor(entry, [options])</code></h4>\n<p>Creates a cursor that can seek and traverse parts of the file.</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> cursor = archive.createByteCursor(<span class=\"hljs-string\">'hello.txt'</span>)\n\n<span class=\"hljs-comment\">// seek to byte offset 10000 and read the rest.</span>\ncursor.seek(<span class=\"hljs-number\">10000</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err\n  cursor.next(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">loop</span> (<span class=\"hljs-params\">err, data</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err\n    <span class=\"hljs-keyword\">if</span> (!data) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'no more data'</span>)\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'cursor.position is '</span> + cursor.position)\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'read'</span>, data.length, <span class=\"hljs-string\">'bytes'</span>)\n    cursor.next(loop)\n  })\n})\n</code></pre>\n<p>Options include</p>\n<pre><code class=\"lang-js\">{\n  start: startOffset, <span class=\"hljs-comment\">// defaults to 0</span>\n  end: endOffset <span class=\"hljs-comment\">// defaults to file.length</span>\n}\n</code></pre>\n<h4 id=\"-var-stream-archive-replicate-\"><code>var stream = archive.replicate()</code></h4>\n<p>Pipe this stream together with another peer that is interested in the same archive to replicate the content.</p>\n<h2 id=\"license\">License</h2>\n<p>MIT</p>\n","hyperdrive-archive-swarm":"<h1 id=\"hyperdrive-archive-swarm\">hyperdrive-archive-swarm</h1>\n<p>Join a hyperdrive archive&#39;s &amp; hypercore feed&#39;s p2p swarm in the client and server.</p>\n<pre><code>npm <span class=\"hljs-keyword\">install</span> hyperdrive-<span class=\"hljs-keyword\">archive</span>-swarm\n</code></pre><h2 id=\"usage\">Usage</h2>\n<p>Run the following code in two different places and they will replicate the contents of the given <code>ARCHIVE_KEY</code>.</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> hyperdrive = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'hyperdrive'</span>)\n<span class=\"hljs-keyword\">var</span> memdb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'memdb'</span>)\n<span class=\"hljs-keyword\">var</span> swarm = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'hyperdrive-archive-swarm'</span>)\n\n<span class=\"hljs-keyword\">var</span> drive = hyperdrive(memdb())\n<span class=\"hljs-keyword\">var</span> archive = drive.createArchive(<span class=\"hljs-string\">'ARCHIVE_KEY'</span>)\n\n<span class=\"hljs-keyword\">var</span> sw = swarm(archive)\nsw.on(<span class=\"hljs-string\">'connection'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">peer, type</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'got'</span>, peer, type) <span class=\"hljs-comment\">// type is 'webrtc-swarm' or 'discovery-swarm'</span>\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'connected to'</span>, sw.connections, <span class=\"hljs-string\">'peers'</span>)\n  peer.on(<span class=\"hljs-string\">'close'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'peer disconnected'</span>)\n  }) \n})\n</code></pre>\n<p>Will use <code>discovery-swarm</code>, and <code>webrtc-swarm</code> whenever available to attempt to connect peers. Uses <code>datland-swarm-defaults</code> for peer introduction defaults on the server side, which can be overwritten (see below).</p>\n<p>The module can also create and join a swarm for a hypercore feed:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> hypercore = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'hypercore'</span>)\n<span class=\"hljs-keyword\">var</span> memdb = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'memdb'</span>)\n<span class=\"hljs-keyword\">var</span> swarm = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'hyperdrive-archive-swarm'</span>)\n\n<span class=\"hljs-keyword\">var</span> core = hypercore(memdb())\n<span class=\"hljs-keyword\">var</span> feed = core.createFeed()\n<span class=\"hljs-keyword\">var</span> sw = swarm(feed)\n</code></pre>\n<h2 id=\"api\">API</h2>\n<h3 id=\"-var-sw-swarm-archive-opts-\"><code>var sw = swarm(archive, opts)</code></h3>\n<p>Join the p2p swarm for the given hyperdrive archive. The return object, <code>sw</code>, is an event emitter that will emit a <code>peer</code> event with the peer information when a peer is found.</p>\n<p>Get number of currently active connections with <code>sw.connections</code>.</p>\n<h5 id=\"options\">Options</h5>\n<ul>\n<li><code>signalhub</code>: the url of the signalhub.</li>\n<li><code>signalhubPrefix</code>: the prefix for the archive&#39;s signalhub key</li>\n<li><code>wrtc</code>: a webrtc instance, e.g. electron-webrtc, if not natively supported</li>\n</ul>\n<p>Defaults from datland-swarm-defaults can also be overwritten:</p>\n<ul>\n<li><code>dns.server</code>: DNS server</li>\n<li><code>dns.domain</code>: DNS domain</li>\n<li><code>dht.bootstrap</code>: distributed hash table bootstrapping nodes</li>\n</ul>\n","hyperdrive-ui":"<h1 id=\"hyperdrive-ui\">hyperdrive-ui</h1>\n<p>Explore the contents of a <a href=\"http://github.com/mafintosh/hyperdrive\">hyperdrive</a> in the browser.</p>\n<h2 id=\"example\">Example</h2>\n<p>Live demo: <a href=\"http://dat.land/\">http://dat.land/</a></p>\n<h2 id=\"usage\">usage</h2>\n<p><code>npm install hyperdrive-ui</code></p>\n<h2 id=\"-hyperdriveui-archive-opts-onclick-\"><code>hyperdriveUI(archive, opts, onclick)</code></h2>\n<p>Renders the explorer.</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> explorer = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'hyperdrive-ui'</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">onclick</span> (<span class=\"hljs-params\">ev, entry</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'clicked'</span>, entry.name, entry.type)\n}\n<span class=\"hljs-keyword\">var</span> tree = explorer(archive, onclick)\n<span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">'#hyperdrive'</span>).appendChild(tree)\n</code></pre>\n<h2 id=\"get-started\">get started</h2>\n<pre><code><span class=\"hljs-built_in\">npm</span> install\n<span class=\"hljs-built_in\">npm</span> start\n</code></pre>","website":"<h1 id=\"dat-website\">dat website</h1>\n<h3 id=\"run-locally\">run locally</h3>\n<pre><code><span class=\"hljs-built_in\">npm</span> install\n<span class=\"hljs-built_in\">npm</span> start\n</code></pre><h3 id=\"add-a-post\">add a post</h3>\n<p>Create a <code>.md</code> file in <code>posts/</code>.</p>\n<p>Create an entry in <code>posts.js</code>.</p>\n<p>Find it at <code>/blog/&lt;name&gt;</code>.</p>\n<p>When you&#39;re ready to publish it, add a <code>date</code>. Posts without a <code>date</code> are not public.</p>\n<h3 id=\"deploy\">deploy</h3>\n<p>push <code>master</code> to github then run:</p>\n<pre><code>npm <span class=\"hljs-built_in\">run</span> deploy\n</code></pre>","jawn":"<h1 id=\"dat-jawn-git-for-tabular-data-\">dat jawn: &#39;Git for Tabular Data&#39;</h1>\n<p><a href=\"https://travis-ci.org/CfABrigadePhiladelphia/jawn\"><img src=\"https://travis-ci.org/CfABrigadePhiladelphia/jawn.svg?branch=master\" alt=\"Build Status\"></a></p>\n<p><a href=\"https://nodei.co/npm/jawn/\"><img src=\"https://nodei.co/npm/jawn.png\" alt=\"NPM\"></a></p>\n<p>Jawn is a node.js module that allows <em>distributed version control of Tabular Data</em>. It&#39;s connected to the <a href=\"https://github.com/maxogden/dat\">dat</a> project. It allows you to import tabular data (rows and columns like CSV or TSV) and track how those data change over time. <em>Do you have non-tabular data? read this:</em> <a href=\"https://github.com/CfABrigadePhiladelphia/jawn/wiki/What-about-Non-Tabular-Data%3F\">What about Non Tabular Data?</a>  </p>\n<p>The key features for jawn are to:</p>\n<ul>\n<li><strong>manage and track change history</strong> in tabular data</li>\n<li><strong>create historical checkpoints</strong> with metadata (e.g., message, timestamp, author)</li>\n</ul>\n<p>Jawn relies on <a href=\"https://github.com/mafintosh/hypercore\">hypercore</a> to handle the core functions around creating merkle chains, which allows us to </p>\n<ul>\n<li><strong>supply access points to data</strong> across the network with a peer-to-peer model</li>\n<li><strong>sync incrementally</strong> between machines</li>\n</ul>\n<p>This is where jawn connects with the current work of the dat team, who created hypercore and are using it to do the same things with directories of files. For more background info, read our <a href=\"https://github.com/CfABrigadePhiladelphia/jawn/wiki/Technical-Background-and-Reference-Code-Bases\">Technical Background and Reference Code Bases</a> wiki page.</p>\n<h2 id=\"project-team\">Project Team</h2>\n<p>jawn is maintained by a <a href=\"https://codeforphilly.org\">Code for Philly</a> project that aims to be a model for mentorship and collaborative learning. For full information about the project go to the <a href=\"https://codeforphilly.org/projects/dat_tables\">jawn project page</a>  </p>\n<p>We welcome contributions from anyone.</p>\n<h2 id=\"usage\">Usage</h2>\n<p><em>work in progress</em></p>\n<h2 id=\"contributing\">Contributing</h2>\n<p><em>work in progress</em></p>\n<p>If you want to work on the jawn code, first clone the repository and cd into that directory, then install the node dependencies and run the tests with these commands: </p>\n<pre><code><span class=\"hljs-built_in\">npm</span> install\n<span class=\"hljs-built_in\">npm</span> test\n</code></pre>"}})
  css('/Users/joe/node_modules/dat-world/assets/styles.css', { global: true })
  app.start('#choo-root')
  