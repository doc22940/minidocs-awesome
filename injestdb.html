<!doctype html>
<html lang="en" dir="ltr">
<head>
<title>Awesome Dat</title>
<meta charset="utf-8">

<link rel="stylesheet" href="/bundle.css">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/style.css">
</head>
<body>
<div id="choo-root" class="_d4e87350 minidocs flex flex-column m0 h-100">
      <div class="minidocs-header-flex flex">
        <header class="_19f2d18a minidocs-header ph4 w-100 bg-black-90">
    <nav class="flex justify-between">
      <div class="flex items-center">
        <div class="menu-button">
          <a class=" menu-toggle"></a>
        </div>
        <a href="/" title="Awesome Dat" class="inline-flex items-center">
        <img src="/dat-data-logo.svg" alt="Awesome Dat" class="minidocs-header-logo dib w2 h2" />
        <span class="minidocs-header-title ml2 pr2 white">Awesome Dat</span>
      </a>
      </div>
      <div class="minidocs-header-nav flex-grow flex items-center tr ttu">
        <a href="/install" title="Install" class="minidocs-header-link white dim link dn dib-ns mr3-ns">Install</a>
        <a href="http://datproject.org/" title="Home" class="minidocs-header-link white dim link dib mr3-ns">Home</a>
      </div>
    </nav>
  </header>
      </div>
      <main class="minidocs-main-flex flex">
        <div class="minidocs-sidebar-flex open order-0 overflow-auto bg-near-white">
        <div class="_068b628f minidocs-menu pa3">
      <div class="f3 pt2">Welcome</div><div><a href="/awesome-dat" class="content-link ">Awesome Dat</a></div><div class="f3 pt2">Dat Applications</div><div><a href="/dat" class="content-link ">datproject/dat</a></div><div><a href="/dat-desktop" class="content-link ">datproject/dat-desktop</a></div><div class="f3 pt2">Community Applications</div><div><a href="/sciencefair" class="content-link ">codeforscience/sciencefair</a></div><div><a href="/hyperirc" class="content-link ">mafintosh/hyperirc</a></div><div><a href="/soundcloud-archiver" class="content-link ">jondashkyle/soundcloud-archiver</a></div><div><a href="/hypervision" class="content-link ">mafintosh/hypervision</a></div><div><a href="/hypertweet" class="content-link ">joehand/hypertweet</a></div><div><a href="/dat-photos-app" class="content-link ">beakerbrowser/dat-photos-app</a></div><div class="f3 pt2">High-Level APIs</div><div><a href="/dat-node" class="content-link ">datproject/dat-node</a></div><div><a href="/dat-js" class="content-link ">datproject/dat-js</a></div><div><a href="/pauls-dat-api" class="content-link ">beakerbrowser/pauls-dat-api</a></div><div><a href="/node-dat-archive" class="content-link ">beakerbrowser/node-dat-archive</a></div><div class="f3 pt2">Hosting &amp; Dat Management</div><div><a href="/hypercore-archiver" class="content-link ">mafintosh/hypercore-archiver</a></div><div><a href="/hypercloud" class="content-link ">datprotocol/hypercloud</a></div><div><a href="/hashbase" class="content-link ">beakerbrowser/hashbase</a></div><div><a href="/dat-now" class="content-link ">joehand/dat-now</a></div><div><a href="/hypercore-archiver-bot" class="content-link ">mafintosh/hypercore-archiver-bot</a></div><div><a href="/hypercore-archiver-ws" class="content-link ">joehand/hypercore-archiver-ws</a></div><div><a href="/dat-registry-api" class="content-link ">datproject/dat-registry-api</a></div><div><a href="/dat-registry-client" class="content-link ">datproject/dat-registry-client</a></div><div class="f3 pt2">Managing &amp; Aggregating Dats</div><div><a href="/multidat" class="content-link ">datproject/multidat</a></div><div><a href="/multidrive" class="content-link ">datproject/multidrive</a></div><div><a href="/dat-pki" class="content-link ">jayrbolton/dat-pki</a></div><div>
            <a href="/injestdb" class="content-link active">beakerbrowser/injestdb</a>
            <div class="minidocs-menu-toc">
              <a href="#todos" class="f5 content-link">TODOs</a><a href="#api-quick-reference" class="f5 content-link">API quick reference</a><a href="#api" class="f5 content-link">API</a><a href="#how-it-works" class="f5 content-link">How it works</a>
            </div>
          </div><div class="f3 pt2">Http Hosting</div><div><a href="/hyperdrive-http" class="content-link ">joehand/hyperdrive-http</a></div><div><a href="/dathttpd" class="content-link ">beakerbrowser/dathttpd</a></div><div class="f3 pt2">Dat Link Utilties</div><div><a href="/dat-dns" class="content-link ">datprotocol/dat-dns</a></div><div><a href="/dat-link-resolve" class="content-link ">joehand/dat-link-resolve</a></div><div><a href="/parse-dat-url" class="content-link ">pfrazee/parse-dat-url</a></div><div><a href="/dat-encoding" class="content-link ">juliangruber/dat-encoding</a></div><div class="f3 pt2">Dat Utilities</div><div><a href="/dat-log" class="content-link ">joehand/dat-log</a></div><div><a href="/dat-ls" class="content-link ">mafintosh/dat-ls</a></div><div><a href="/hyperhealth" class="content-link ">karissa/hyperhealth</a></div><div><a href="/hyperdrive-network-speed" class="content-link ">joehand/hyperdrive-network-speed</a></div><div class="f3 pt2">File Imports &amp; Exports</div><div><a href="/hyperdrive-import-files" class="content-link ">juliangruber/hyperdrive-import-files</a></div><div><a href="/mirror-folder" class="content-link ">mafintosh/mirror-folder</a></div><div><a href="/hyperdrive-staging-area" class="content-link ">pfrazee/hyperdrive-staging-area</a></div><div><a href="/hyperdrive-to-zip-stream" class="content-link ">pfrazee/hyperdrive-to-zip-stream</a></div><div class="f3 pt2">Hypercore Tools</div><div><a href="/hyperpipe" class="content-link ">mafintosh/hyperpipe</a></div><div class="f3 pt2">Dat Core Modules</div><div><a href="/hyperdrive" class="content-link ">mafintosh/hyperdrive</a></div><div><a href="/hypercore" class="content-link ">mafintosh/hypercore</a></div><div class="f3 pt2">CLI Utilities</div><div><a href="/dat-doctor" class="content-link ">joehand/dat-doctor</a></div><div><a href="/dat-ignore" class="content-link ">joehand/dat-ignore</a></div><div><a href="/dat-json" class="content-link ">joehand/dat-json</a></div><div class="f3 pt2">Networking</div><div><a href="/hyperdiscovery" class="content-link ">karissa/hyperdiscovery</a></div><div><a href="/discovery-swarm" class="content-link ">mafintosh/discovery-swarm</a></div><div><a href="/webrtc-swarm" class="content-link ">mafintosh/webrtc-swarm</a></div><div><a href="/dat-swarm-defaults" class="content-link ">joehand/dat-swarm-defaults</a></div><div class="f3 pt2">Lower level networking modules</div><div><a href="/discovery-channel" class="content-link ">maxogden/discovery-channel</a></div><div><a href="/dns-discovery" class="content-link ">mafintosh/dns-discovery</a></div><div><a href="/multicast-dns" class="content-link ">mafintosh/multicast-dns</a></div><div><a href="/bittorrent-dht" class="content-link ">webtorrent/bittorrent-dht</a></div><div><a href="/utp-native" class="content-link ">mafintosh/utp-native</a></div><div><a href="/signalhub" class="content-link ">mafintosh/signalhub</a></div><div class="f3 pt2">Storage</div><div><a href="/dat-storage" class="content-link ">datproject/dat-storage</a></div><div><a href="/dat-secret-storage" class="content-link ">datproject/dat-secret-storage</a></div><div class="f3 pt2">Random Access</div><div><a href="/abstract-random-access" class="content-link ">juliangruber/abstract-random-access</a></div><div><a href="/multi-random-access" class="content-link ">mafintosh/multi-random-access</a></div><div><a href="/random-access-file" class="content-link ">mafintosh/random-access-file</a></div><div><a href="/random-access-memory" class="content-link ">mafintosh/random-access-memory</a></div><div><a href="/random-access-page-files" class="content-link ">mafintosh/random-access-page-files</a></div><div><a href="/dat-http" class="content-link ">datproject/dat-http</a></div><div><a href="/random-access-idb" class="content-link ">substack/random-access-idb</a></div><div class="f3 pt2">Other Related Dat Project Modules</div><div><a href="/peer-network" class="content-link ">mafintosh/peer-network</a></div><div><a href="/hyperdht" class="content-link ">mafintosh/hyperdht</a></div><div class="f3 pt2">Dat Project Organization Stuff</div><div><a href="/datproject.org" class="content-link ">datproject/datproject.org</a></div><div><a href="/discussions" class="content-link ">datproject/discussions</a></div><div><a href="/design" class="content-link ">datproject/design</a></div><div><a href="/dat-elements" class="content-link ">datproject/dat-elements</a></div><div><a href="/dat-colors" class="content-link ">kriesse/dat-colors</a></div><div><a href="/dat-icons" class="content-link ">kriesse/dat-icons</a></div><div><a href="/dat.json" class="content-link ">juliangruber/dat.json</a></div><div class="f3 pt2">Outdated</div><div><a href="/dat.haus" class="content-link ">juliangruber/dat.haus</a></div><div><a href="/hyperfeed" class="content-link ">poga/hyperfeed</a></div><div><a href="/normcore" class="content-link ">yoshuawuyts/normcore</a></div><div><a href="/github-to-hypercore" class="content-link ">yoshuawuyts/github-to-hypercore</a></div><div><a href="/hyperspark" class="content-link ">poga/hyperspark</a></div><div><a href="/hypercore-index" class="content-link ">juliangruber/hypercore-index</a></div><div><a href="/hyperdrive-encoding" class="content-link ">juliangruber/hyperdrive-encoding</a></div><div><a href="/hyperdrive-http-server" class="content-link ">mafintosh/hyperdrive-http-server</a></div><div><a href="/hyperdrive-http" class="content-link ">joehand/hyperdrive-http</a></div><div><a href="/dat-push" class="content-link ">joehand/dat-push</a></div><div><a href="/dat-backup" class="content-link ">joehand/dat-backup</a></div><div><a href="/archiver-server" class="content-link ">joehand/archiver-server</a></div><div><a href="/archiver-api" class="content-link ">joehand/archiver-api</a></div><div><a href="/hyperdrive-ln" class="content-link ">poga/hyperdrive-ln</a></div><div><a href="/hyperdrive-multiwriter" class="content-link ">substack/hyperdrive-multiwriter</a></div><div><a href="/hyperdrive-named-archives" class="content-link ">substack/hyperdrive-named-archives</a></div><div><a href="/git-dat" class="content-link ">substack/git-dat</a></div><div><a href="/jawn" class="content-link ">CfABrigadePhiladelphia/jawn</a></div><div><a href="/dat-archiver" class="content-link ">maxogden/dat-archiver</a></div><div><a href="/hyperdrive-stats" class="content-link ">juliangruber/hyperdrive-stats</a></div><div><a href="/hypercore-stats-server" class="content-link ">karissa/hypercore-stats-server</a></div><div><a href="/hypercore-stats-ui" class="content-link ">mafintosh/hypercore-stats-ui</a></div><div><a href="/zip-to-hyperdrive" class="content-link ">karissa/zip-to-hyperdrive</a></div><div><a href="/url-dat" class="content-link ">joehand/url-dat</a></div><div><a href="/tar-dat" class="content-link ">joehand/tar-dat</a></div><div><a href="/hyperdrive-duplicate" class="content-link ">joehand/hyperdrive-duplicate</a></div>
    </div>
      </div>
        <div id="minidocs-content" class="minidocs-content-flex order-1 overflow-auto">
          <div class="_32076d68 pa3 ph5-ns pv4-ns">
    
    
    <div><h1 id="injestdb"><a href="#injestdb" class="anchor"></a>InjestDB</h1><p>A peer-to-peer database for dat:// applications. <a href="#how-it-works">How it works</a></p>
<h4 id="example"><a href="#example" class="anchor"></a>Example</h4><p>Setup a database for social profiles, which can publish status updates and like other users&#39; posts.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> Injest = <span class="hljs-built_in">require</span>(<span class="hljs-string">'injestdb'</span>)
<span class="hljs-keyword">var</span> db = <span class="hljs-keyword">new</span> Injest(<span class="hljs-string">'social-profiles'</span>)
db.schema({
  <span class="hljs-attr">version</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">broadcasts</span>: {
    <span class="hljs-attr">primaryKey</span>: <span class="hljs-string">'createdAt'</span>,
    <span class="hljs-attr">index</span>: [
      <span class="hljs-string">'createdAt'</span>,
      <span class="hljs-string">'_origin+createdAt'</span> <span class="hljs-comment">// compound index. '_origin' is an autogenerated attribute which represets the URL of the authoring archive</span>
    ],
    <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-params">record</span> =&gt;</span> {
      assert(<span class="hljs-keyword">typeof</span> record.text === <span class="hljs-string">'string'</span>)
      assert(<span class="hljs-keyword">typeof</span> record.createdAt === <span class="hljs-string">'number'</span>)
      <span class="hljs-keyword">return</span> record
    }
  },
  <span class="hljs-attr">likes</span>: {
    <span class="hljs-attr">primaryKey</span>: <span class="hljs-string">'createdAt'</span>,
    <span class="hljs-attr">index</span>: <span class="hljs-string">'targetUrl'</span>,
    <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-params">record</span> =&gt;</span> {
      assert(<span class="hljs-keyword">typeof</span> record.targetUrl === <span class="hljs-string">'string'</span>)
      <span class="hljs-keyword">return</span> record
    }
  },
  <span class="hljs-attr">profile</span>: {
    <span class="hljs-attr">singular</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">index</span>: <span class="hljs-string">'name'</span>,
    <span class="hljs-attr">validator</span>: <span class="hljs-function"><span class="hljs-params">record</span> =&gt;</span> {
      assert(<span class="hljs-keyword">typeof</span> record.name === <span class="hljs-string">'string'</span>)
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">name</span>: record.name,
        <span class="hljs-attr">description</span>: isString(record.description) ? record.description : <span class="hljs-string">''</span>,
        <span class="hljs-attr">avatarUrl</span>: isString(record.avatarUrl) ? record.avatarUrl : <span class="hljs-string">''</span>
      }
    }
  }
})
</code></pre>
<p>Next we add source archives to be ingested (added ot the dataset). The source archives are persisted in IndexedDB, so this doesn&#39;t have to be done every run.</p>
<pre><code class="lang-js"><span class="hljs-keyword">await</span> db.addArchives([alicesUrl, bobsUrl, carlasDatArchive], {<span class="hljs-attr">prepare</span>: <span class="hljs-literal">true</span>})
</code></pre>
<p>Now we can begin querying the database for records.</p>
<pre><code class="lang-js"><span class="hljs-comment">// get the first profile record where name === 'bob'</span>
<span class="hljs-keyword">var</span> bobProfile = <span class="hljs-keyword">await</span> db.profiles.get(<span class="hljs-string">'name'</span>, <span class="hljs-string">'bob'</span>)

<span class="hljs-comment">// get all profile records which match this query</span>
<span class="hljs-keyword">var</span> bobProfiles = <span class="hljs-keyword">await</span> db.profiles
  .where(<span class="hljs-string">'name'</span>)
  .equalsIgnoreCase(<span class="hljs-string">'bob'</span>)
  .toArray()

<span class="hljs-comment">// get the 30 latest broadcasts from all source archives</span>
<span class="hljs-keyword">var</span> recentBroadcasts = <span class="hljs-keyword">await</span> db.broadcasts
  .orderBy(<span class="hljs-string">'createdAt'</span>)
  .reverse() <span class="hljs-comment">// most recent first</span>
  .limit(<span class="hljs-number">30</span>)
  .toArray()

<span class="hljs-comment">// get the 30 latest broadcasts by a specific archive (bob)</span>
<span class="hljs-comment">// - this uses a compound index to filter by origin, and then sort by createdAt</span>
<span class="hljs-keyword">var</span> bobsRecentBroadcasts = <span class="hljs-keyword">await</span> db.broadcasts
  .where(<span class="hljs-string">'_origin+createdAt'</span>)
  .between([bobsUrl, <span class="hljs-string">''</span>], [bobsUrl, <span class="hljs-string">'\uffff'</span>])
  .reverse() <span class="hljs-comment">// most recent first</span>
  .limit(<span class="hljs-number">30</span>)
  .toArray()

<span class="hljs-comment">// get the # of likes for a broadcast</span>
<span class="hljs-keyword">var</span> numLikes = <span class="hljs-keyword">await</span> db.likes
  .where(<span class="hljs-string">'targetUrl'</span>).equals(bobsRecentBroadcasts[<span class="hljs-number">0</span>]._url) <span class="hljs-comment">// _url is an autogenerated attribute which represents the URL of the record</span>
  .count()
</code></pre>
<p>We can also use Injest to create, modify, and delete records (and their matching files).</p>
<pre><code class="lang-js"><span class="hljs-comment">// update bob's name</span>
<span class="hljs-keyword">await</span> db.profiles.update(bobsUrl, {<span class="hljs-attr">name</span>: <span class="hljs-string">'robert'</span>})

<span class="hljs-comment">// publish a new broadcast for bob</span>
<span class="hljs-keyword">var</span> broadcastUrl = <span class="hljs-keyword">await</span> db.broadcasts.add(bobsUrl, {
  <span class="hljs-attr">text</span>: <span class="hljs-string">'Hello!'</span>,
  <span class="hljs-attr">createdAt</span>: <span class="hljs-built_in">Date</span>.now()
})

<span class="hljs-comment">// modify the broadcast</span>
<span class="hljs-keyword">await</span> db.broadcasts.update(broadcastUrl, {<span class="hljs-attr">text</span>: <span class="hljs-string">'Hello world!'</span>})

<span class="hljs-comment">// like the broadcast</span>
<span class="hljs-keyword">await</span> db.likes.add(bobsUrl, {
  <span class="hljs-attr">targetUrl</span>: broadcastUrl,
  <span class="hljs-attr">createdAt</span>: <span class="hljs-built_in">Date</span>.now()
})

<span class="hljs-comment">// delete the broadcast</span>
<span class="hljs-keyword">await</span> db.broadcasts.delete(broadcastUrl)

<span class="hljs-comment">// delete all likes on the broadcast (that we control)</span>
<span class="hljs-keyword">await</span> db.likes
  .where({<span class="hljs-attr">targetUrl</span>: broadcastUrl})
  .delete()
</code></pre>
<h2 id="todos"><a href="#todos" class="anchor"></a>TODOs</h2><p>Injest is still in development.</p>
<ul>
<li>[x] Indexer</li>
<li>[x] Core query engine</li>
<li>[x] Persisted tables and table reindex on schema change</li>
<li>[x] Mutation methods (add/update/delete)</li>
<li>[ ] Events</li>
<li>[x] Multikey indexes</li>
<li>[ ] Validation: filename must match primaryKey on non-singular tables</li>
<li>[ ] Support for .or() queries</li>
<li>[ ] Complete documentation</li>
</ul>
<h2 id="api-quick-reference"><a href="#api-quick-reference" class="anchor"></a>API quick reference</h2><pre><code class="lang-js">var db = new InjestDB(name)
InjestDB.list() =&gt; Promise&lt;Void&gt;
InjestDB.delete(name) =&gt; Promise&lt;Void&gt;
db.open() =&gt; Promise&lt;Void&gt;
db.close() =&gt; Promise&lt;Void&gt;
db.schema(Object) =&gt; Promise&lt;Void&gt;
db.addArchive(url|DatArchive, {prepare: Boolean}) =&gt; Promise&lt;Void&gt;
db.addArchives(Array&lt;url|DatArchive&gt;, {prepare: Boolean}) =&gt; Promise&lt;Void&gt;
db.removeArchive(url|DatArchive) =&gt; Promise&lt;Void&gt;
db.prepareArchive(url|DatArchive)
db.listArchives() =&gt; Promise&lt;url&gt;
db 'open' ()
db 'open-failed' (error)
db 'versionchange' ()
db 'indexes-updated' (archive, archiveVersion)

db.{table} =&gt; InjestTable
InjestTable#add(archive, record) =&gt; Promise&lt;url&gt;
InjestTable#count() =&gt; Promise&lt;Number&gt;
InjestTable#delete(url) =&gt; Promise&lt;url&gt;
InjestTable#each(Function) =&gt; Promise&lt;Void&gt;
InjestTable#filter(Function) =&gt; InjestRecordset
InjestTable#get(url) =&gt; Promise&lt;Object&gt;
InjestTable#get(archive) =&gt; Promise&lt;Object&gt;
InjestTable#get(archive, key) =&gt; Promise&lt;Object&gt;
InjestTable#get(index, value) =&gt; Promise&lt;Object&gt;
InjestTable#isRecordFile(String) =&gt; Boolean
InjestTable#limit(Number) =&gt; InjestRecordset
InjestTable#listRecordFiles(Archive) =&gt; Promise&lt;Object&gt;
InjestTable#name =&gt; String
InjestTable#offset(Number) =&gt; InjestRecordset
InjestTable#orderBy(index) =&gt; InjestRecordset
InjestTable#put(url, record) =&gt; Promise&lt;url&gt;
InjestTable#reverse() =&gt; InjestRecordset
InjestTable#schema =&gt; Object
InjestTable#toArray() =&gt; Promise&lt;Array&gt;
InjestTable#toCollection() =&gt; InjestRecordset
InjestTable#update(record) =&gt; Promise&lt;Number&gt;
InjestTable#update(url, updates) =&gt; Promise&lt;Number&gt;
InjestTable#update(archive, updates) =&gt; Promise&lt;Number&gt;
InjestTable#update(archive, key, updates) =&gt; Promise&lt;Number&gt;
InjestTable#upsert(url, record) =&gt; Promise&lt;Void | url&gt;
InjestTable#upsert(archive, record) =&gt; Promise&lt;Void | url&gt;
InjestTable#where(index) =&gt; InjestWhereClause
InjestTable 'index-updated' (archive, archiveVersion)

InjestWhereClause#above(lowerBound) =&gt; InjestRecordset
InjestWhereClause#aboveOrEqual(lowerBound) =&gt; InjestRecordset
InjestWhereClause#anyOf(Array|...args) =&gt; InjestRecordset
InjestWhereClause#anyOfIgnoreCase(Array|...args) =&gt; InjestRecordset
InjestWhereClause#below(upperBound) =&gt; InjestRecordset
InjestWhereClause#belowOrEqual(upperBound) =&gt; InjestRecordset
InjestWhereClause#between(lowerBound, upperBound, {includeUpper, includeLower}) =&gt; InjestRecordset
InjestWhereClause#equals(value) =&gt; InjestRecordset
InjestWhereClause#equalsIgnoreCase(value) =&gt; InjestRecordset
InjestWhereClause#noneOf(Array|...args) =&gt; InjestRecordset
InjestWhereClause#notEqual(value) =&gt; InjestRecordset
InjestWhereClause#startsWith(value) =&gt; InjestRecordset
InjestWhereClause#startsWithAnyOf(Array|...args) =&gt; InjestRecordset
InjestWhereClause#startsWithAnyOfIgnoreCase(Array|...args) =&gt; InjestRecordset
InjestWhereClause#startsWithIgnoreCase(value) =&gt; InjestRecordset

InjestRecordset#clone() =&gt; InjestRecordset
InjestRecordset#count() =&gt; Promise&lt;Number&gt;
InjestRecordset#delete() =&gt; Promise&lt;Number&gt;
InjestRecordset#distinct() =&gt; InjestRecordset
InjestRecordset#each(Function) =&gt; Promise&lt;Void&gt;
InjestRecordset#eachKey(Function) =&gt; Promise&lt;Void&gt;
InjestRecordset#eachUrl(Function) =&gt; Promise&lt;Void&gt;
InjestRecordset#filter(Function) =&gt; InjestRecordset
InjestRecordset#first() =&gt; Promise&lt;Object&gt;
InjestRecordset#keys() =&gt; Promise&lt;Array&lt;String&gt;&gt;
InjestRecordset#last() =&gt; Promise&lt;Object&gt;
InjestRecordset#limit(Number) =&gt; InjestRecordset
InjestRecordset#offset(Number) =&gt; InjestRecordset
InjestRecordset#or(index) =&gt; InjestWhereClause
InjestRecordset#put(Object) =&gt; Promise&lt;Number&gt;
InjestRecordset#urls() =&gt; Promise&lt;Array&lt;String&gt;&gt;
InjestRecordset#reverse() =&gt; InjestRecordset
InjestRecordset#toArray() =&gt; Promise&lt;Array&lt;Object&gt;&gt;
InjestRecordset#uniqueKeys() =&gt; Promise&lt;Array&lt;String&gt;&gt;
InjestRecordset#until(Function) =&gt; InjestRecordset
InjestRecordset#update(Object|Function) =&gt; Promise&lt;Number&gt;
InjestRecordset#where(index) =&gt; InjestWhereClause
</code></pre>
<h2 id="api"><a href="#api" class="anchor"></a>API</h2><h3 id="dbschemadefinition"><a href="#dbschemadefinition" class="anchor"></a>db.schema(definition)</h3><pre><code class="lang-js">{
  <span class="hljs-attr">version</span>: <span class="hljs-built_in">Number</span>, <span class="hljs-comment">// the version # of the schema, should increment by 1 on each change</span>

  [tableName]: {
    <span class="hljs-comment">// is there only one record-file per archive?</span>
    <span class="hljs-comment">// - if true, will look for the file at `/${tableName}.json`</span>
    <span class="hljs-comment">// - if false, will look for files at `/${tableName}/*.json`</span>
    singular: <span class="hljs-built_in">Boolean</span>,

    <span class="hljs-comment">// attribute to build filenames for newly-created records</span>
    <span class="hljs-comment">// ie `/${tableName}/${record[primaryKey]}.json`</span>
    <span class="hljs-comment">// only required if !singular</span>
    primaryKey: <span class="hljs-built_in">String</span>, 

    <span class="hljs-comment">// specify which fields are indexed for querying</span>
    <span class="hljs-comment">// each is a keypath, see https://www.w3.org/TR/IndexedDB/#dfn-key-path</span>
    <span class="hljs-comment">// can specify compound indexes with a + separator in the keypath</span>
    <span class="hljs-comment">// eg one index               - index: 'firstName' </span>
    <span class="hljs-comment">// eg two indexes             - index: ['firstName', 'lastName']</span>
    <span class="hljs-comment">// eg add a compound index    - index: ['firstName', 'lastName', 'firstName+lastName']</span>
    <span class="hljs-comment">// eg index an array's values - index: ['firstName', '*favoriteFruits']</span>
    index: <span class="hljs-built_in">String</span>|<span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">String</span>&gt;,

    <span class="hljs-comment">// validator &amp; sanitizer</span>
    <span class="hljs-comment">// takes the ingested file (must be valid json)</span>
    <span class="hljs-comment">// returns the record to be stored</span>
    <span class="hljs-comment">// returns falsy or throws to not store the record</span>
    validator: <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">Object</span>) =&gt; <span class="hljs-built_in">Object</span>
  }
}
</code></pre>
<h2 id="how-it-works"><a href="#how-it-works" class="anchor"></a>How it works</h2><p>InjestDB abstracts over the <a href="https://beakerbrowser.com/docs/apis/dat.html">DatArchive API</a> to provide a simple database-like interface. It is based heavily on <a href="https://github.com/dfahlander/Dexie.js">Dexie.js</a> and built using IndexedDB.</p>
<p>Injest works by scanning a set of source archives for files that match a path pattern. Those files are indexed (&quot;ingested&quot;) so that they can be queried easily. Injest also provides a simple interface for adding, editing, and removing records on the archives that the local user owns.</p>
<p>Injest sits on top of Dat archives. It duplicates the data it&#39;s handling into IndexedDB, and that duplicated data acts as a throwaway cache -- it can be reconstructed at any time from the Dat archives.</p>
<p>Injest treats individual files in the Dat archive as individual records in a table. As a result, there&#39;s a direct mapping for each table to a folder of .json files. For instance, if you had a &#39;tweets&#39; table, it would map to the <code>/tweets/*.json</code> files. Injest&#39;s mutators, such as put or add or update, simply write those json files. Injest&#39;s readers &amp; query-ers, such as get() or where(), read from the IndexedDB cache.</p>
<p>Injest watches its source archives for changes to the json files. When they change, it reads them and updates IndexedDB, thus the query results stay up-to-date. The flow is, roughly: <code>put() -&gt; archive/tweets/12345.json -&gt; indexer -&gt; indexeddb -&gt; get()</code>.</p>
</div>
  </div>
        </div>
      </main>
    </div>
<script src="/bundle.js"></script>
</body>
</html>
