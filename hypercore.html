<!doctype html>
<html lang="en" dir="ltr">
<head>
<title>Awesome Dat</title>
<meta charset="utf-8">

<link rel="stylesheet" href="/bundle.css">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/style.css">
</head>
<body>
<div id="choo-root" class="_d4e87350 minidocs flex flex-column m0 h-100">
      <div class="minidocs-header-flex flex">
        <header class="_19f2d18a minidocs-header ph4 w-100 bg-black-90">
    <nav class="flex justify-between">
      <div class="flex items-center">
        <div class="menu-button">
          <a class=" menu-toggle"></a>
        </div>
        <a href="/" title="Awesome Dat" class="inline-flex items-center">
        <img src="/dat-data-logo.svg" alt="Awesome Dat" class="minidocs-header-logo dib w2 h2" />
        <span class="minidocs-header-title ml2 pr2 white">Awesome Dat</span>
      </a>
      </div>
      <div class="minidocs-header-nav flex-grow flex items-center tr ttu">
        <a href="/install" title="Install" class="minidocs-header-link white dim link dn dib-ns mr3-ns">Install</a>
        <a href="http://datproject.org/" title="Home" class="minidocs-header-link white dim link dib mr3-ns">Home</a>
      </div>
    </nav>
  </header>
      </div>
      <main class="minidocs-main-flex flex">
        <div class="minidocs-sidebar-flex open order-0 overflow-auto bg-near-white">
        <div class="_068b628f minidocs-menu pa3">
      <div class="f3 pt2">Welcome</div><div><a href="/awesome-dat" class="content-link ">Awesome Dat</a></div><div class="f3 pt2">Dat Applications</div><div><a href="/dat" class="content-link ">datproject/dat</a></div><div><a href="/dat-desktop" class="content-link ">datproject/dat-desktop</a></div><div class="f3 pt2">Community Applications</div><div><a href="/sciencefair" class="content-link ">codeforscience/sciencefair</a></div><div><a href="/hyperirc" class="content-link ">mafintosh/hyperirc</a></div><div><a href="/soundcloud-archiver" class="content-link ">jondashkyle/soundcloud-archiver</a></div><div><a href="/hypervision" class="content-link ">mafintosh/hypervision</a></div><div><a href="/hypertweet" class="content-link ">joehand/hypertweet</a></div><div><a href="/dat-photos-app" class="content-link ">beakerbrowser/dat-photos-app</a></div><div class="f3 pt2">High-Level APIs</div><div><a href="/dat-node" class="content-link ">datproject/dat-node</a></div><div><a href="/dat-js" class="content-link ">datproject/dat-js</a></div><div><a href="/pauls-dat-api" class="content-link ">beakerbrowser/pauls-dat-api</a></div><div><a href="/node-dat-archive" class="content-link ">beakerbrowser/node-dat-archive</a></div><div class="f3 pt2">Hosting &amp; Dat Management</div><div><a href="/hypercore-archiver" class="content-link ">mafintosh/hypercore-archiver</a></div><div><a href="/hypercloud" class="content-link ">datprotocol/hypercloud</a></div><div><a href="/hashbase" class="content-link ">beakerbrowser/hashbase</a></div><div><a href="/dat-now" class="content-link ">joehand/dat-now</a></div><div><a href="/hypercore-archiver-bot" class="content-link ">mafintosh/hypercore-archiver-bot</a></div><div><a href="/hypercore-archiver-ws" class="content-link ">joehand/hypercore-archiver-ws</a></div><div><a href="/dat-registry-api" class="content-link ">datproject/dat-registry-api</a></div><div><a href="/dat-registry-client" class="content-link ">datproject/dat-registry-client</a></div><div class="f3 pt2">Managing &amp; Aggregating Dats</div><div><a href="/multidat" class="content-link ">datproject/multidat</a></div><div><a href="/multidrive" class="content-link ">datproject/multidrive</a></div><div><a href="/dat-pki" class="content-link ">jayrbolton/dat-pki</a></div><div><a href="/injestdb" class="content-link ">beakerbrowser/injestdb</a></div><div class="f3 pt2">Http Hosting</div><div><a href="/hyperdrive-http" class="content-link ">joehand/hyperdrive-http</a></div><div><a href="/dathttpd" class="content-link ">beakerbrowser/dathttpd</a></div><div class="f3 pt2">Dat Link Utilties</div><div><a href="/dat-dns" class="content-link ">datprotocol/dat-dns</a></div><div><a href="/dat-link-resolve" class="content-link ">joehand/dat-link-resolve</a></div><div><a href="/parse-dat-url" class="content-link ">pfrazee/parse-dat-url</a></div><div><a href="/dat-encoding" class="content-link ">juliangruber/dat-encoding</a></div><div class="f3 pt2">Dat Utilities</div><div><a href="/dat-log" class="content-link ">joehand/dat-log</a></div><div><a href="/dat-ls" class="content-link ">mafintosh/dat-ls</a></div><div><a href="/hyperhealth" class="content-link ">karissa/hyperhealth</a></div><div><a href="/hyperdrive-network-speed" class="content-link ">joehand/hyperdrive-network-speed</a></div><div class="f3 pt2">File Imports &amp; Exports</div><div><a href="/hyperdrive-import-files" class="content-link ">juliangruber/hyperdrive-import-files</a></div><div><a href="/mirror-folder" class="content-link ">mafintosh/mirror-folder</a></div><div><a href="/hyperdrive-staging-area" class="content-link ">pfrazee/hyperdrive-staging-area</a></div><div><a href="/hyperdrive-to-zip-stream" class="content-link ">pfrazee/hyperdrive-to-zip-stream</a></div><div class="f3 pt2">Hypercore Tools</div><div><a href="/hyperpipe" class="content-link ">mafintosh/hyperpipe</a></div><div class="f3 pt2">Dat Core Modules</div><div><a href="/hyperdrive" class="content-link ">mafintosh/hyperdrive</a></div><div>
            <a href="/hypercore" class="content-link active">mafintosh/hypercore</a>
            <div class="minidocs-menu-toc">
              <a href="#features" class="f5 content-link">Features</a><a href="#usage" class="f5 content-link">Usage</a><a href="#api" class="f5 content-link">API</a><a href="#license" class="f5 content-link">License</a>
            </div>
          </div><div class="f3 pt2">CLI Utilities</div><div><a href="/dat-doctor" class="content-link ">joehand/dat-doctor</a></div><div><a href="/dat-ignore" class="content-link ">joehand/dat-ignore</a></div><div><a href="/dat-json" class="content-link ">joehand/dat-json</a></div><div class="f3 pt2">Networking</div><div><a href="/hyperdiscovery" class="content-link ">karissa/hyperdiscovery</a></div><div><a href="/discovery-swarm" class="content-link ">mafintosh/discovery-swarm</a></div><div><a href="/webrtc-swarm" class="content-link ">mafintosh/webrtc-swarm</a></div><div><a href="/dat-swarm-defaults" class="content-link ">joehand/dat-swarm-defaults</a></div><div class="f3 pt2">Lower level networking modules</div><div><a href="/discovery-channel" class="content-link ">maxogden/discovery-channel</a></div><div><a href="/dns-discovery" class="content-link ">mafintosh/dns-discovery</a></div><div><a href="/multicast-dns" class="content-link ">mafintosh/multicast-dns</a></div><div><a href="/bittorrent-dht" class="content-link ">webtorrent/bittorrent-dht</a></div><div><a href="/utp-native" class="content-link ">mafintosh/utp-native</a></div><div><a href="/signalhub" class="content-link ">mafintosh/signalhub</a></div><div class="f3 pt2">Storage</div><div><a href="/dat-storage" class="content-link ">datproject/dat-storage</a></div><div><a href="/dat-secret-storage" class="content-link ">datproject/dat-secret-storage</a></div><div class="f3 pt2">Random Access</div><div><a href="/abstract-random-access" class="content-link ">juliangruber/abstract-random-access</a></div><div><a href="/multi-random-access" class="content-link ">mafintosh/multi-random-access</a></div><div><a href="/random-access-file" class="content-link ">mafintosh/random-access-file</a></div><div><a href="/random-access-memory" class="content-link ">mafintosh/random-access-memory</a></div><div><a href="/random-access-page-files" class="content-link ">mafintosh/random-access-page-files</a></div><div><a href="/dat-http" class="content-link ">datproject/dat-http</a></div><div><a href="/random-access-idb" class="content-link ">substack/random-access-idb</a></div><div class="f3 pt2">Other Related Dat Project Modules</div><div><a href="/peer-network" class="content-link ">mafintosh/peer-network</a></div><div><a href="/hyperdht" class="content-link ">mafintosh/hyperdht</a></div><div class="f3 pt2">Dat Project Organization Stuff</div><div><a href="/datproject.org" class="content-link ">datproject/datproject.org</a></div><div><a href="/discussions" class="content-link ">datproject/discussions</a></div><div><a href="/design" class="content-link ">datproject/design</a></div><div><a href="/dat-elements" class="content-link ">datproject/dat-elements</a></div><div><a href="/dat-colors" class="content-link ">kriesse/dat-colors</a></div><div><a href="/dat-icons" class="content-link ">kriesse/dat-icons</a></div><div><a href="/dat.json" class="content-link ">juliangruber/dat.json</a></div><div class="f3 pt2">Outdated</div><div><a href="/dat.haus" class="content-link ">juliangruber/dat.haus</a></div><div><a href="/hyperfeed" class="content-link ">poga/hyperfeed</a></div><div><a href="/normcore" class="content-link ">yoshuawuyts/normcore</a></div><div><a href="/github-to-hypercore" class="content-link ">yoshuawuyts/github-to-hypercore</a></div><div><a href="/hyperspark" class="content-link ">poga/hyperspark</a></div><div><a href="/hypercore-index" class="content-link ">juliangruber/hypercore-index</a></div><div><a href="/hyperdrive-encoding" class="content-link ">juliangruber/hyperdrive-encoding</a></div><div><a href="/hyperdrive-http-server" class="content-link ">mafintosh/hyperdrive-http-server</a></div><div><a href="/hyperdrive-http" class="content-link ">joehand/hyperdrive-http</a></div><div><a href="/dat-push" class="content-link ">joehand/dat-push</a></div><div><a href="/dat-backup" class="content-link ">joehand/dat-backup</a></div><div><a href="/archiver-server" class="content-link ">joehand/archiver-server</a></div><div><a href="/archiver-api" class="content-link ">joehand/archiver-api</a></div><div><a href="/hyperdrive-ln" class="content-link ">poga/hyperdrive-ln</a></div><div><a href="/hyperdrive-multiwriter" class="content-link ">substack/hyperdrive-multiwriter</a></div><div><a href="/hyperdrive-named-archives" class="content-link ">substack/hyperdrive-named-archives</a></div><div><a href="/git-dat" class="content-link ">substack/git-dat</a></div><div><a href="/jawn" class="content-link ">CfABrigadePhiladelphia/jawn</a></div><div><a href="/dat-archiver" class="content-link ">maxogden/dat-archiver</a></div><div><a href="/hyperdrive-stats" class="content-link ">juliangruber/hyperdrive-stats</a></div><div><a href="/hypercore-stats-server" class="content-link ">karissa/hypercore-stats-server</a></div><div><a href="/hypercore-stats-ui" class="content-link ">mafintosh/hypercore-stats-ui</a></div><div><a href="/zip-to-hyperdrive" class="content-link ">karissa/zip-to-hyperdrive</a></div><div><a href="/url-dat" class="content-link ">joehand/url-dat</a></div><div><a href="/tar-dat" class="content-link ">joehand/tar-dat</a></div><div><a href="/hyperdrive-duplicate" class="content-link ">joehand/hyperdrive-duplicate</a></div>
    </div>
      </div>
        <div id="minidocs-content" class="minidocs-content-flex order-1 overflow-auto">
          <div class="_32076d68 pa3 ph5-ns pv4-ns">
    
    
    <div><h1 id="hypercore"><a href="#hypercore" class="anchor"></a>hypercore</h1><p>Hypercore is a secure, distributed append-only log.</p>
<p>Built for sharing large datasets and streams of real time data as part of the <a href="https://datproject.org">Dat project</a>.</p>
<pre><code class="lang-sh">npm install hypercore
</code></pre>
<p><a href="https://travis-ci.org/mafintosh/hypercore"><img src="https://travis-ci.org/mafintosh/hypercore.svg?branch=master" alt="Build Status"></a></p>
<p>To learn more about how hypercore works on a technical level read the <a href="https://github.com/datproject/docs/blob/master/papers/dat-paper.pdf">Dat paper</a>.</p>
<h2 id="features"><a href="#features" class="anchor"></a>Features</h2><ul>
<li>Sparse replication. Only download the data you are interested in.</li>
<li>Realtime. Get the latest updates to the log fast and securely.</li>
<li>Performant. Uses a simple flat file structure to maximize I/O performance.</li>
<li>Secure. Uses signed merkle trees to verify log integrity in real time.</li>
<li>Browser support. Simply pick a storage provider (like <a href="https://github.com/mafintosh/random-access-memory">random-access-memory</a>) that works in the browser</li>
</ul>
<h2 id="usage"><a href="#usage" class="anchor"></a>Usage</h2><pre><code class="lang-js"><span class="hljs-keyword">var</span> hypercore = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hypercore'</span>)
<span class="hljs-keyword">var</span> feed = hypercore(<span class="hljs-string">'./my-first-dataset'</span>, {<span class="hljs-attr">valueEncoding</span>: <span class="hljs-string">'utf-8'</span>})

feed.append(<span class="hljs-string">'hello'</span>)
feed.append(<span class="hljs-string">'world'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err
  feed.get(<span class="hljs-number">0</span>, <span class="hljs-built_in">console</span>.log) <span class="hljs-comment">// prints hello</span>
  feed.get(<span class="hljs-number">1</span>, <span class="hljs-built_in">console</span>.log) <span class="hljs-comment">// prints world</span>
})
</code></pre>
<h2 id="api"><a href="#api" class="anchor"></a>API</h2><h4 id="var-feed-hypercorestorage-key-options"><a href="#var-feed-hypercorestorage-key-options" class="anchor"></a><code>var feed = hypercore(storage, [key], [options])</code></h4><p>Create a new hypercore feed.</p>
<p><code>storage</code> should be set to a directory where you want to store the data and feed metadata.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> feed = hypercore(<span class="hljs-string">'./directory'</span>) <span class="hljs-comment">// store data in ./directory</span>
</code></pre>
<p>Alternatively you can pass a function instead that is called with every filename hypercore needs to function and return your own <a href="https://github.com/juliangruber/abstract-random-access">random-access</a> instance that is used to store the data.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> ram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'random-access-memory'</span>)
<span class="hljs-keyword">var</span> feed = hypercore(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">filename</span>) </span>{
  <span class="hljs-comment">// filename will be one of: data, bitfield, tree, signatures, key, secret_key</span>
  <span class="hljs-comment">// the data file will contain all your data concattenated.</span>

  <span class="hljs-comment">// just store all files in ram by returning a random-access-memory instance</span>
  <span class="hljs-keyword">return</span> ram()
})
</code></pre>
<p>Per default hypercore uses <a href="https://github.com/mafintosh/random-access-file">random-access-file</a>. This is also useful if you want to store specific files in other directories. For example you might want to store the secret key elsewhere.</p>
<p><code>key</code> can be set to a hypercore feed public key. If you do not set this the public key will be loaded from storage. If no key exists a new key pair will be generated.</p>
<p><code>options</code> include:</p>
<pre><code class="lang-js">{
  <span class="hljs-attr">createIfMissing</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// create a new hypercore key pair if none was present in storage</span>
  overwrite: <span class="hljs-literal">false</span>, <span class="hljs-comment">// overwrite any old hypercore that might already exist</span>
  valueEncoding: <span class="hljs-string">'json'</span> | <span class="hljs-string">'utf-8'</span> | <span class="hljs-string">'binary'</span>, <span class="hljs-comment">// defaults to binary</span>
  sparse: <span class="hljs-literal">false</span>, <span class="hljs-comment">// do not mark the entire feed to be downloaded</span>
  secretKey: buffer <span class="hljs-comment">// optionally pass the corresponding secret key yourself</span>
  storeSecretKey: <span class="hljs-literal">true</span> <span class="hljs-comment">// if false, will not save the secret key</span>
}
</code></pre>
<p>You can also set valueEncoding to any <a href="https://github.com/mafintosh/abstract-encoding">abstract-encoding</a> instance.</p>
<h4 id="feedwritable"><a href="#feedwritable" class="anchor"></a><code>feed.writable</code></h4><p>Can we append to this feed?</p>
<p>Populated after <code>ready</code> has been emitted. Will be <code>false</code> before the event.</p>
<h4 id="feedreadable"><a href="#feedreadable" class="anchor"></a><code>feed.readable</code></h4><p>Can we read from this feed? After closing a feed this will be false.</p>
<p>Populated after <code>ready</code> has been emitted. Will be <code>false</code> before the event.</p>
<h4 id="feedkey"><a href="#feedkey" class="anchor"></a><code>feed.key</code></h4><p>Buffer containing the public key identifying this feed.</p>
<p>Populated after <code>ready</code> has been emitted. Will be <code>null</code> before the event.</p>
<h4 id="feeddiscoverykey"><a href="#feeddiscoverykey" class="anchor"></a><code>feed.discoveryKey</code></h4><p>Buffer containing a key derived from the feed.key.
In contrast to <code>feed.key</code> this key does not allow you to verify the data but can be used to announce or look for peers that are sharing the same feed, without leaking the feed key.</p>
<p>Populated after <code>ready</code> has been emitted. Will be <code>null</code> before the event.</p>
<h4 id="feedlength"><a href="#feedlength" class="anchor"></a><code>feed.length</code></h4><p>How many blocks of data are available on this feed?</p>
<p>Populated after <code>ready</code> has been emitted. Will be <code>0</code> before the event.</p>
<h4 id="feedbytelength"><a href="#feedbytelength" class="anchor"></a><code>feed.byteLength</code></h4><p>How much data is available on this feed in bytes?</p>
<p>Populated after <code>ready</code> has been emitted. Will be <code>0</code> before the event.</p>
<h4 id="feedgetindex-options-callback"><a href="#feedgetindex-options-callback" class="anchor"></a><code>feed.get(index, [options], callback)</code></h4><p>Get a block of data.
If the data is not available locally this method will prioritize and wait for the data to be downloaded before calling the callback.</p>
<p>Options include</p>
<pre><code class="lang-js">{
  <span class="hljs-attr">wait</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// wait for index to be downloaded</span>
  timeout: <span class="hljs-number">0</span>, <span class="hljs-comment">// wait at max some milliseconds (0 means no timeout)</span>
  valueEncoding: <span class="hljs-string">'json'</span> | <span class="hljs-string">'utf-8'</span> | <span class="hljs-string">'binary'</span> <span class="hljs-comment">// defaults to the feed's valueEncoding</span>
}
</code></pre>
<p>Callback is called with <code>(err, data)</code></p>
<h4 id="feedheadoptions-callback"><a href="#feedheadoptions-callback" class="anchor"></a><code>feed.head([options], callback)</code></h4><p>Get the block of data at the tip of the feed. This will be the most recently
appended block.</p>
<p>Accepts the same <code>options</code> as <code>feed.get()</code>.</p>
<h4 id="feeddownloadrange-callback"><a href="#feeddownloadrange-callback" class="anchor"></a><code>feed.download([range], [callback])</code></h4><p>Download a range of data. Callback is called when all data has been downloaded.
A range can have the following properties:</p>
<pre><code class="lang-js">{
  <span class="hljs-attr">start</span>: startIndex,
  <span class="hljs-attr">end</span>: nonInclusiveEndIndex,
  <span class="hljs-attr">linear</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// download range linearly and not randomly</span>
}
</code></pre>
<p>If you do not mark a range the entire feed will be marked for download.</p>
<p>If you have not enabled sparse mode (<code>sparse: true</code> in the feed constructor) then the entire
feed will be marked for download for you when the feed is created.</p>
<h4 id="feedundownloadrange"><a href="#feedundownloadrange" class="anchor"></a><code>feed.undownload(range)</code></h4><p>Cancel a previous download request.</p>
<h4 id="var-number-feeddownloadedstart-end"><a href="#var-number-feeddownloadedstart-end" class="anchor"></a><code>var number = feed.downloaded([start], [end])</code></h4><p>Returns total number of downloaded blocks within range.
If <code>end</code> is not specified it will default to the total number of blocks.
If <code>start</code> is not specified it will default to 0.</p>
<h4 id="var-bool-feedhasindex"><a href="#var-bool-feedhasindex" class="anchor"></a><code>var bool = feed.has(index)</code></h4><p>Return true if a data block is available locally.
False otherwise.</p>
<h4 id="var-bool-feedhasstart-end"><a href="#var-bool-feedhasstart-end" class="anchor"></a><code>var bool = feed.has(start, end)</code></h4><p>Return true if all data blocks within a range are available locally.
False otherwise.</p>
<h4 id="feedappenddata-callback"><a href="#feedappenddata-callback" class="anchor"></a><code>feed.append(data, [callback])</code></h4><p>Append a block of data to the feed.</p>
<p>Callback is called with <code>(err)</code> when all data has been written or an error occured.</p>
<h4 id="feedclearstart-end-callback"><a href="#feedclearstart-end-callback" class="anchor"></a><code>feed.clear(start, [end], [callback])</code></h4><p>Clear a range of data from the local cache.
Will clear the data from the bitfield and make a call to the underlying storage provider to delete the byte range the range occupies.</p>
<p><code>end</code> defaults to <code>start + 1</code>.</p>
<h4 id="feedseekbyteoffset-callback"><a href="#feedseekbyteoffset-callback" class="anchor"></a><code>feed.seek(byteOffset, callback)</code></h4><p>Seek to a byte offset.</p>
<p>Calls the callback with <code>(err, index, relativeOffset)</code>, where <code>index</code> is the data block the byteOffset is contained in and <code>relativeOffset</code> is
the relative byte offset in the data block.</p>
<h4 id="feedupdateminlength-callback"><a href="#feedupdateminlength-callback" class="anchor"></a><code>feed.update([minLength], [callback])</code></h4><p>Wait for the feed to contain at least <code>minLength</code> elements.
If you do not provide <code>minLength</code> it will be set to current length + 1.</p>
<p>Does not download any data from peers except for a proof of the new feed length.</p>
<pre><code class="lang-js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'length is'</span>, feed.length)
feed.update(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'length has increased'</span>, feed.length)
})
</code></pre>
<h4 id="var-stream-feedcreatereadstreamoptions"><a href="#var-stream-feedcreatereadstreamoptions" class="anchor"></a><code>var stream = feed.createReadStream([options])</code></h4><p>Create a readable stream of data.</p>
<p>Options include:</p>
<pre><code class="lang-js">{
  <span class="hljs-attr">start</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// read from this index</span>
  end: feed.length, <span class="hljs-comment">// read until this index</span>
  snapshot: <span class="hljs-literal">true</span>, <span class="hljs-comment">// if set to false it will update `end` to `feed.length` on every read</span>
  tail: <span class="hljs-literal">false</span>, <span class="hljs-comment">// sets `start` to `feed.length`</span>
  live: <span class="hljs-literal">false</span>, <span class="hljs-comment">// set to true to keep reading forever</span>
  timeout: <span class="hljs-number">0</span>, <span class="hljs-comment">// timeout for each data event (0 means no timeout)</span>
  wait: <span class="hljs-literal">true</span> <span class="hljs-comment">// wait for data to be downloaded</span>
}
</code></pre>
<h4 id="var-stream-feedcreatewritestream"><a href="#var-stream-feedcreatewritestream" class="anchor"></a><code>var stream = feed.createWriteStream()</code></h4><p>Create a writable stream.</p>
<h4 id="var-stream-feedreplicateoptions"><a href="#var-stream-feedreplicateoptions" class="anchor"></a><code>var stream = feed.replicate([options])</code></h4><p>Create a replication stream. You should pipe this to another hypercore instance.</p>
<pre><code class="lang-js"><span class="hljs-comment">// assuming we have two feeds, localFeed + remoteFeed, sharing the same key</span>
<span class="hljs-comment">// on a server</span>
<span class="hljs-keyword">var</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>)
<span class="hljs-keyword">var</span> server = net.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">socket</span>) </span>{
  socket.pipe(remoteFeed.replicate()).pipe(socket)
})

<span class="hljs-comment">// on a client</span>
<span class="hljs-keyword">var</span> socket = net.connect(...)
socket.pipe(localFeed.replicate()).pipe(socket)
</code></pre>
<p>Options include:</p>
<pre><code class="lang-js">{
  <span class="hljs-attr">live</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// keep replicating after all remote data has been downloaded?</span>
  download: <span class="hljs-literal">true</span>, <span class="hljs-comment">// download data from peers?</span>
  encrypt: <span class="hljs-literal">true</span> <span class="hljs-comment">// encrypt the data sent using the hypercore key pair</span>
}
</code></pre>
<h4 id="feedclosecallback"><a href="#feedclosecallback" class="anchor"></a><code>feed.close([callback])</code></h4><p>Fully close this feed.</p>
<p>Calls the callback with <code>(err)</code> when all storage has been closed.</p>
<h4 id="feedonready"><a href="#feedonready" class="anchor"></a><code>feed.on(&#39;ready&#39;)</code></h4><p>Emitted when the feed is ready and all properties have been populated.</p>
<h4 id="feedonerror-err"><a href="#feedonerror-err" class="anchor"></a><code>feed.on(&#39;error&#39;, err)</code></h4><p>Emitted when the feed experiences a critical error.</p>
<h4 id="feedondownload-index-data"><a href="#feedondownload-index-data" class="anchor"></a><code>feed.on(&#39;download&#39;, index, data)</code></h4><p>Emitted when a data block has been downloaded.</p>
<h4 id="feedonupload-index-data"><a href="#feedonupload-index-data" class="anchor"></a><code>feed.on(&#39;upload&#39;, index, data)</code></h4><p>Emitted when a data block is uploaded.</p>
<h4 id="feedonappend"><a href="#feedonappend" class="anchor"></a><code>feed.on(&#39;append&#39;)</code></h4><p>Emitted when the feed has been appended to (i.e. has a new length / byteLength)</p>
<h4 id="feedonsync"><a href="#feedonsync" class="anchor"></a><code>feed.on(&#39;sync&#39;)</code></h4><p>Emitted everytime ALL data from <code>0</code> to <code>feed.length</code> has been downloaded.</p>
<h4 id="feedonclose"><a href="#feedonclose" class="anchor"></a><code>feed.on(&#39;close&#39;)</code></h4><p>Emitted when the feed has been fully closed</p>
<h2 id="license"><a href="#license" class="anchor"></a>License</h2><p>MIT</p>
</div>
  </div>
        </div>
      </main>
    </div>
<script src="/bundle.js"></script>
</body>
</html>
